/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.6.0
 * Mon, 01 Apr 2024 13:56:08 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    /**
     * Get an HTML element by the given id.
     * @param {(string|Array<string>)} id An HTML element id or an array in the
     * format ["CONTAINER"] (app's container HTML element), or in the format
     * ["WINDOW"] (page's window object), or in the format ["DOCUMENT"] (page's
     * document object), or in the format ["BODY"] (document's body element) or in
     * the format ["QUERYSELECTOR"] (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for the element.
     * @returns {?(HTMLElement|Window|Document)} An HTML element, window,
     * document depending on the given "id" parameter or "null" if nothing was
     * found.
     */
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
    
    /**
     * Get an array of HTML elements or a single HTML element by the given ids/id.
     * @param {Array<string>} ids An array of HTML element ids or an array with its
     * first element being "CONTAINER" (app's container HTML element),
     * "WINDOW" (page's window object), "DOCUMENT" (page's document object),
     * "BODY" (document's body element) or "QUERYSELECTOR" (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for elements.
     * @returns {?(Array<?HTMLElement>|HTMLElement|Window|Document)} An array of
     * HTML elements or a single HTML element, window, document depending on the
     * given "ids" parameter or "null" if nothing was found.
     */
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    /**
     * Check if the given object is "worth processing", i.e. not irrelevant nor
     * purely utilitarian. This function is useful for listing all relevant objects
     * from a scene (see "objectList" and "groupList" puzzles) and for filtering out
     * irrelevant ones when traversing a scene.
     * @param {v3d.Object3D} obj Object to check.
     * @returns {boolean} Check result.
     */
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
    
    /**
     * Get object by its name from the scene.
     * @param {string} objName Object name.
     * @returns {?v3d.Object3D} Object or null if not found.
     */
    function getObjectByName(objName) {
        let objFound = null;
    
        const runTime = _pGlob !== undefined;
        if (runTime && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (runTime) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    /**
     * Get the names of all objects belonging to the given group.
     * @param {string} groupName Group name.
     * @returns {Array<string>} Array of names of all objects belonging to the given
     * group.
     */
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    /**
     * Get the names of all objects on the scene.
     * @returns {Array<string>} Array of names of all scene objects.
     */
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    /**
     * Accumulate object names from the given "currObjNames" parameter.
     * This is just a helper function which is supposed to be called from
     * "retrieveObjectNames".
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @param {Array<string>} namesAccum Array accumulating object names.
     */
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    /**
     * Retreive object names from the given "objNames" parameter which potentially
     * represents an object, or an array of objects, or a group or all objects at
     * once. Empty string names ('') are always filtered out.
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @returns {Array<string>} Array of retrieved object names.
     */
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    /**
     * Check whether 2 event listeners are the same or not.
     * NOTE: "capture" is the only option that affects the fact if the listeners are
     * the same or not.
     * @see https://dom.spec.whatwg.org/#ref-for-dom-eventtarget-addeventlistener%E2%91%A2
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal
     * @param {EventTarget} target0 Event target the first event listener is
     * registered on.
     * @param {string} type0 Event type of the first even listener.
     * @param {?Function} listener0 Listener object (null, function or an object
     * with a handleEvent() method) of the first event listener.
     * @param {(Object|boolean)} optionsOrUseCapture0 Event listener options (or the
     * useCapture flag) of the first event listener.
     * @param {EventTarget} target1 Event target the second listener is registered
     * on.
     * @param {string} type1 Event type of the second even listener.
     * @param {?Function} listener1 Listener object (null, function or an object
     * with a handleEvent() method) of the second event listener.
     * @param {(Object|boolean)} optionsOrUseCapture1 Event listener options (or the
     * useCapture flag) of the second event listener.
     * @returns {boolean} Check result.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
    
    /**
     * Add the specified event listener to the specified event target. Also register
     * it in _pGlob.eventListeners for easier removal further. This function doesn't
     * add the exact same listener if it was already added.
     *
     * NOTE: automatic removal of an event listener via options.once and
     * options.signal is not reflected in _pGlob.eventListeners. In such cases
     * one must call unbindListener() manually to keep _pGlob.eventListeners
     * updated and to avoid potential issues with how the code checks if the given
     * listener already exists in _pGlob.eventListeners or not.
     *
     * @param {EventTarget} target Event target.
     * @param {string} type Event type.
     * @param {?Function} listener Listener object (null, function or an object
     * with a handleEvent() method).
     * @param {(Object|boolean)} optionsOrUseCapture Event listener options (or the
     * useCapture flag).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    /**
     * Transform the given coordinates from one space to another. Can be used with
     * both v3d.Vector3 or v3d.Euler.
     * @param {(v3d.Vector3|v3d.Euler)} coords Coordinates to transform.
     * @param {string} spaceFrom Space to transform from.
     * @param {string} spaceTo Space to transform into.
     * @param {boolean} [noSignChange=false] Don't change a component's sign in case
     * of the Z->(-Y), Y->(-Z) transformations. "true" is relevant for vectors
     * containing values that shouldn't change the sign (e.g. scale, dimension,
     * etc...).
     * @returns {(v3d.Vector3|v3d.Euler)} Transformed coordinates.
     */
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
    
    /**
     * Transform the given euler rotation from Verge3D's to Blender/Max's coordinate
     * system while also choosing the shortest rotation to resemble Blender's
     * behavior:
     * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Maxdefault
     * order) via reversion: XYZ -> ZYX.
     * 2) Swizzle ZYX->YZX.
     * 3) Choose the shortest rotation.
     *
     * @param {v3d.Euler} euler Euler rotation in Verge3D's coordinate system.
     * @param {v3d.Euler} dest Destination euler vector.
     * @returns {v3d.Euler} Destination vector filled with the transformed
     * coordinates.
     */
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    /**
     * Get the coordinate system of the current scene.
     * @returns {string} Scene's coordinate system.
     */
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
    
    /**
     * Create a new RotationInterface object.
     * @class
     * @classdesc Class for facilitating rotations similar to how they work in
     * Blender/Max/Maya's UI. E.g. the axes for user rotations are similar to
     * Blender's "Gimbal" object gizmos for translation ("Move").
     */
    function RotationInterface() {
        /**
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
    
    /**
     * Default value used in certain list selector puzzles like "objectList",
     * "groupList", "animationList" and "materialList". Useful for checking for the
     * "nothing selected" case.
     * @constant
     * @type {string}
     * @default
     */
    const LIST_NONE = '<none>';

    return {
        getElements, getObjectByName, retrieveObjectNames, bindListener,
        transformCoordsSpace, transformEulerV3dToBlenderShortest, getSceneCoordSystem, RotationInterface,
        LIST_NONE, getElement,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}



// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemStyle('visibility', String(Math.round(_initGlob.percentage)) + '%', 'logo_preloader', true);
  registerSetTimeout(2, function() {
    setHTMLElemAttribute('innerHTML', String(Math.round(_initGlob.percentage)) + '%', 'percentage', true);
  });
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'preloader_screen', true);
})();
};


// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}



var switch2, kong_tag_30cm_cegid00000, kong_tag_62cm_cegid11111, kong_tag_180cm_cegid22222;

// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'CHROMEOS':
        return /(CrOS)/.test(userAgent);
    case 'LINUX':
        return /Linux/.test(platform);

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBAUDIO':
        return v3d.Detector.checkWebAudio();
    case 'WEBGL':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl')
        return !!gl;
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        var woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
        return !!woo_fun;
    case 'DO_NOT_TRACK':
        if (navigator.doNotTrack == '1' || window.doNotTrack == '1')
            return true;
        else
            return false;
    default:
        return false;
    }

}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// assignMaterial puzzle
function assignMat(objSelector, matName) {
    var objNames = PzLib.retrieveObjectNames(objSelector);
    if (!matName)
        return;
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (obj) {
            var firstSubmesh = obj.resolveMultiMaterial()[0];
            firstSubmesh.material = mat;
        }
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// isObjectVisible puzzle
function isObjectVisible(objSelector) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (obj.visible)
            return true;
    }
    return false;
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = PzLib.RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}

// zoomCamera puzzle
function zoomCamera(objSelector, duration, doSlot) {

    duration = Math.max(0, duration);

    const objNames = PzLib.retrieveObjectNames(objSelector);

    const zoomObjects = [];
    objNames.forEach(function(name) {
        const obj = PzLib.getObjectByName(name);
        if (obj) {
            zoomObjects.push(obj);
        }
    });

    if (!zoomObjects.length) {
        return;
    }

    const camera = appInstance.getCamera();

    const zoom = [camera.zoom]; // for orthographic camera only

    const pos = _pGlob.vec3Tmp, target = _pGlob.vec3Tmp2;
    v3d.CameraUtils.calcCameraZoomToObjectsParams(camera, zoomObjects,
            pos, target, zoom);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            if (camera.isOrthographicCamera) {
                appInstance.controls.tweenZoomTo(target, zoom[0],
                        duration, doSlot);
            } else {
                appInstance.controls.tween(pos, target, duration, doSlot);
            }
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(pos);
        }
        camera.position.copy(pos);
        camera.lookAt(target);
        camera.zoom = zoom[0];
        camera.updateProjectionMatrix();
        doSlot();
    }
}

var actionDisabled = false;

!function(n,e){"use strict";
/*!
   fflate - fast JavaScript compression/decompression
   <https://101arrowz.github.io/fflate>
   Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
   version 0.6.9
   */var t=function(n){return URL.createObjectURL(new Blob([n],{type:"text/javascript"}))};try{URL.revokeObjectURL(t(""))}catch(n){t=function(n){return"data:application/javascript;charset=UTF-8,"+encodeURI(n)}}var r=Uint8Array,o=Uint16Array,a=Uint32Array,i=new r([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),s=new r([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),u=new r([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(n,e){for(var t=new o(31),r=0;r<31;++r)t[r]=e+=1<<n[r-1];var i=new a(t[30]);for(r=1;r<30;++r)for(var s=t[r];s<t[r+1];++s)i[s]=s-t[r]<<5|r;return[t,i]},l=f(i,2),c=l[0],p=l[1];c[28]=258,p[258]=28;for(var h=f(s,0)[1],m=new o(32768),d=0;d<32768;++d){var g=(43690&d)>>>1|(21845&d)<<1;g=(61680&(g=(52428&g)>>>2|(13107&g)<<2))>>>4|(3855&g)<<4,m[d]=((65280&g)>>>8|(255&g)<<8)>>>1}var v=function(n,e,t){for(var r=n.length,a=0,i=new o(e);a<r;++a)++i[n[a]-1];var s,u=new o(e);for(a=0;a<e;++a)u[a]=u[a-1]+i[a-1]<<1;if(t){s=new o(1<<e);var f=15-e;for(a=0;a<r;++a)if(n[a])for(var l=a<<4|n[a],c=e-n[a],p=u[n[a]-1]++<<c,h=p|(1<<c)-1;p<=h;++p)s[m[p]>>>f]=l}else for(s=new o(r),a=0;a<r;++a)n[a]&&(s[a]=m[u[n[a]-1]++]>>>15-n[a]);return s},$=new r(288);for(d=0;d<144;++d)$[d]=8;for(d=144;d<256;++d)$[d]=9;for(d=256;d<280;++d)$[d]=7;for(d=280;d<288;++d)$[d]=8;var M=new r(32);for(d=0;d<32;++d)M[d]=5;var x=v($,9,0),w=v(M,5,0),y=function(n){return(n/8|0)+(7&n&&1)},_=function(n,e,t){(null==e||e<0)&&(e=0),(null==t||t>n.length)&&(t=n.length);var i=new(n instanceof o?o:n instanceof a?a:r)(t-e);return i.set(n.subarray(e,t)),i},b=function(n,e,t){t<<=7&e;var r=e/8|0;n[r]|=t,n[r+1]|=t>>>8},S=function(n,e,t){t<<=7&e;var r=e/8|0;n[r]|=t,n[r+1]|=t>>>8,n[r+2]|=t>>>16},U=function(n,e){for(var t=[],a=0;a<n.length;++a)n[a]&&t.push({s:a,f:n[a]});var i=t.length,s=t.slice();if(!i)return[E,0];if(1==i){var u=new r(t[0].s+1);return u[t[0].s]=1,[u,1]}t.sort((function(n,e){return n.f-e.f})),t.push({s:-1,f:25001});var f=t[0],l=t[1],c=0,p=1,h=2;for(t[0]={s:-1,f:f.f+l.f,l:f,r:l};p!=i-1;)f=t[t[c].f<t[h].f?c++:h++],l=t[c!=p&&t[c].f<t[h].f?c++:h++],t[p++]={s:-1,f:f.f+l.f,l:f,r:l};var m=s[0].s;for(a=1;a<i;++a)s[a].s>m&&(m=s[a].s);var d=new o(m+1),g=T(t[p-1],d,0);if(g>e){a=0;var v=0,$=g-e,M=1<<$;for(s.sort((function(n,e){return d[e.s]-d[n.s]||n.f-e.f}));a<i;++a){var x=s[a].s;if(!(d[x]>e))break;v+=M-(1<<g-d[x]),d[x]=e}for(v>>>=$;v>0;){var w=s[a].s;d[w]<e?v-=1<<e-d[w]++-1:++a}for(;a>=0&&v;--a){var y=s[a].s;d[y]==e&&(--d[y],++v)}g=e}return[new r(d),g]},T=function(n,e,t){return-1==n.s?Math.max(T(n.l,e,t+1),T(n.r,e,t+1)):e[n.s]=t},D=function(n){for(var e=n.length;e&&!n[--e];);for(var t=new o(++e),r=0,a=n[0],i=1,s=function(n){t[r++]=n},u=1;u<=e;++u)if(n[u]==a&&u!=e)++i;else{if(!a&&i>2){for(;i>138;i-=138)s(32754);i>2&&(s(i>10?i-11<<5|28690:i-3<<5|12305),i=0)}else if(i>3){for(s(a),--i;i>6;i-=6)s(8304);i>2&&(s(i-3<<5|8208),i=0)}for(;i--;)s(a);i=1,a=n[u]}return[t.subarray(0,r),e]},k=function(n,e){for(var t=0,r=0;r<e.length;++r)t+=n[r]*e[r];return t},P=function(n,e,t){var r=t.length,o=y(e+2);n[o]=255&r,n[o+1]=r>>>8,n[o+2]=255^n[o],n[o+3]=255^n[o+1];for(var a=0;a<r;++a)n[o+a+4]=t[a];return 8*(o+4+r)},j=function(n,e,t,r,a,f,l,c,p,h,m){b(e,m++,t),++a[256];for(var d=U(a,15),g=d[0],y=d[1],_=U(f,15),T=_[0],j=_[1],A=D(g),E=A[0],O=A[1],C=D(T),Z=C[0],R=C[1],L=new o(19),I=0;I<E.length;++I)L[31&E[I]]++;for(I=0;I<Z.length;++I)L[31&Z[I]]++;for(var H=U(L,7),W=H[0],N=H[1],X=19;X>4&&!W[u[X-1]];--X);var z,B,F,G,V=h+5<<3,Y=k(a,$)+k(f,M)+l,q=k(a,g)+k(f,T)+l+14+3*X+k(L,W)+(2*L[16]+3*L[17]+7*L[18]);if(V<=Y&&V<=q)return P(e,m,n.subarray(p,p+h));if(b(e,m,1+(q<Y)),m+=2,q<Y){z=v(g,y,0),B=g,F=v(T,j,0),G=T;var J=v(W,N,0);b(e,m,O-257),b(e,m+5,R-1),b(e,m+10,X-4),m+=14;for(I=0;I<X;++I)b(e,m+3*I,W[u[I]]);m+=3*X;for(var K=[E,Z],Q=0;Q<2;++Q){var nn=K[Q];for(I=0;I<nn.length;++I){var en=31&nn[I];b(e,m,J[en]),m+=W[en],en>15&&(b(e,m,nn[I]>>>5&127),m+=nn[I]>>>12)}}}else z=x,B=$,F=w,G=M;for(I=0;I<c;++I)if(r[I]>255){en=r[I]>>>18&31;S(e,m,z[en+257]),m+=B[en+257],en>7&&(b(e,m,r[I]>>>23&31),m+=i[en]);var tn=31&r[I];S(e,m,F[tn]),m+=G[tn],tn>3&&(S(e,m,r[I]>>>5&8191),m+=s[tn])}else S(e,m,z[r[I]]),m+=B[r[I]];return S(e,m,z[256]),m+B[256]},A=new a([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),E=new r(0),O=function(){for(var n=new a(256),e=0;e<256;++e){for(var t=e,r=9;--r;)t=(1&t&&3988292384)^t>>>1;n[e]=t}return n}(),C=function(){var n=-1;return{p:function(e){for(var t=n,r=0;r<e.length;++r)t=O[255&t^e[r]]^t>>>8;n=t},d:function(){return~n}}},Z=function(n,e,t,u,f){return function(n,e,t,u,f,l){var c=n.length,m=new r(u+c+5*(1+Math.ceil(c/7e3))+f),d=m.subarray(u,m.length-f),g=0;if(!e||c<8)for(var v=0;v<=c;v+=65535){var $=v+65535;$<c?g=P(d,g,n.subarray(v,$)):(d[v]=l,g=P(d,g,n.subarray(v,c)))}else{for(var M=A[e-1],x=M>>>13,w=8191&M,b=(1<<t)-1,S=new o(32768),U=new o(b+1),T=Math.ceil(t/3),D=2*T,k=function(e){return(n[e]^n[e+1]<<T^n[e+2]<<D)&b},O=new a(25e3),C=new o(288),Z=new o(32),R=0,L=0,I=(v=0,0),H=0,W=0;v<c;++v){var N=k(v),X=32767&v,z=U[N];if(S[X]=z,U[N]=X,H<=v){var B=c-v;if((R>7e3||I>24576)&&B>423){g=j(n,d,0,O,C,Z,L,I,W,v-W,g),I=R=L=0,W=v;for(var F=0;F<286;++F)C[F]=0;for(F=0;F<30;++F)Z[F]=0}var G=2,V=0,Y=w,q=X-z&32767;if(B>2&&N==k(v-q))for(var J=Math.min(x,B)-1,K=Math.min(32767,v),Q=Math.min(258,B);q<=K&&--Y&&X!=z;){if(n[v+G]==n[v+G-q]){for(var nn=0;nn<Q&&n[v+nn]==n[v+nn-q];++nn);if(nn>G){if(G=nn,V=q,nn>J)break;var en=Math.min(q,nn-2),tn=0;for(F=0;F<en;++F){var rn=v-q+F+32768&32767,on=rn-S[rn]+32768&32767;on>tn&&(tn=on,z=rn)}}}q+=(X=z)-(z=S[X])+32768&32767}if(V){O[I++]=268435456|p[G]<<18|h[V];var an=31&p[G],sn=31&h[V];L+=i[an]+s[sn],++C[257+an],++Z[sn],H=v+G,++R}else O[I++]=n[v],++C[n[v]]}}g=j(n,d,l,O,C,Z,L,I,W,v-W,g),!l&&7&g&&(g=P(d,g+1,E))}return _(m,0,u+y(g)+f)}(n,null==e.level?6:e.level,null==e.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(n.length)))):12+e.mem,t,u,!f)},R=function(n,e){var t={};for(var r in n)t[r]=n[r];for(var r in e)t[r]=e[r];return t},L=function(n,e,t){for(;t;++e)n[e]=t,t>>>=8};function I(n,e){return Z(n,e||{},0,0)}var H=function(n,e,t,o){for(var a in n){var i=n[a],s=e+a;i instanceof r?t[s]=[i,o]:Array.isArray(i)?t[s]=[i[0],R(o,i[1])]:H(i,s+"/",t,o)}},W="undefined"!=typeof TextEncoder&&new TextEncoder,N="undefined"!=typeof TextDecoder&&new TextDecoder;try{N.decode(E,{stream:!0}),1}catch(n){}function X(n,e){if(e){for(var t=new r(n.length),o=0;o<n.length;++o)t[o]=n.charCodeAt(o);return t}if(W)return W.encode(n);var a=n.length,i=new r(n.length+(n.length>>1)),s=0,u=function(n){i[s++]=n};for(o=0;o<a;++o){if(s+5>i.length){var f=new r(s+8+(a-o<<1));f.set(i),i=f}var l=n.charCodeAt(o);l<128||e?u(l):l<2048?(u(192|l>>6),u(128|63&l)):l>55295&&l<57344?(u(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++o))>>18),u(128|l>>12&63),u(128|l>>6&63),u(128|63&l)):(u(224|l>>12),u(128|l>>6&63),u(128|63&l))}return _(i,0,s)}var z=function(n){var e=0;if(n)for(var t in n){var r=n[t].length;if(r>65535)throw"extra field too long";e+=r+4}return e},B=function(n,e,t,r,o,a,i,s){var u=r.length,f=t.extra,l=s&&s.length,c=z(f);L(n,e,null!=i?33639248:67324752),e+=4,null!=i&&(n[e++]=20,n[e++]=t.os),n[e]=20,e+=2,n[e++]=t.flag<<1|(null==a&&8),n[e++]=o&&8,n[e++]=255&t.compression,n[e++]=t.compression>>8;var p=new Date(null==t.mtime?Date.now():t.mtime),h=p.getFullYear()-1980;if(h<0||h>119)throw"date not in range 1980-2099";if(L(n,e,h<<25|p.getMonth()+1<<21|p.getDate()<<16|p.getHours()<<11|p.getMinutes()<<5|p.getSeconds()>>>1),e+=4,null!=a&&(L(n,e,t.crc),L(n,e+4,a),L(n,e+8,t.size)),L(n,e+12,u),L(n,e+14,c),e+=16,null!=i&&(L(n,e,l),L(n,e+6,t.attrs),L(n,e+10,i),e+=14),n.set(r,e),e+=u,c)for(var m in f){var d=f[m],g=d.length;L(n,e,+m),L(n,e+2,g),n.set(d,e+4),e+=4+g}return l&&(n.set(s,e),e+=l),e};function F(n,e){e||(e={});var t={},o=[];H(n,"",t,e);var a=0,i=0;for(var s in t){var u=t[s],f=u[0],l=u[1],c=0==l.level?0:8,p=(b=X(s)).length,h=l.comment,m=h&&X(h),d=m&&m.length,g=z(l.extra);if(p>65535)throw"filename too long";var v=c?I(f,l):f,$=v.length,M=C();M.p(f),o.push(R(l,{size:f.length,crc:M.d(),c:v,f:b,m:m,u:p!=s.length||m&&h.length!=d,o:a,compression:c})),a+=30+p+g+$,i+=76+2*(p+g)+(d||0)+$}for(var x=new r(i+22),w=a,y=i-a,_=0;_<o.length;++_){var b=o[_];B(x,b.o,b,b.f,b.u,b.c.length);var S=30+b.f.length+z(b.extra);x.set(b.c,b.o+S),B(x,a,b,b.f,b.u,b.c.length,b.o,b.m),a+=16+S+(b.m?b.m.length:0)}return function(n,e,t,r,o){L(n,e,101010256),L(n,e+8,t),L(n,e+10,t),L(n,e+12,r),L(n,e+16,o)}(x,a,o.length,y,w),x}function G(n,e){if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&n instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap){const t=1024/Math.max(n.width,n.height),r=document.createElement("canvas");r.width=n.width*Math.min(1,t),r.height=n.height*Math.min(1,t);const o=r.getContext("2d");if(o.drawImage(n,0,0,r.width,r.height),void 0!==e){const n=parseInt(e,16),t=(n>>16&255)/255,a=(n>>8&255)/255,i=(255&n)/255,s=o.getImageData(0,0,r.width,r.height),u=s.data;for(let n=0;n<u.length;n+=4)u[n+0]=u[n+0]*t,u[n+1]=u[n+1]*a,u[n+2]=u[n+2]*i;o.putImageData(s,0,0)}return r}throw new Error("v3d.USDZExporter: No valid image data found. Unable to process texture.")}const V=7;function Y(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function q(n){const e=n.elements;return`(${J(e,0)}, ${J(e,4)}, ${J(e,8)}, ${J(e,12)})`}function J(n,e){return`(${n[e+0]}, ${n[e+1]}, ${n[e+2]}, ${n[e+3]})`}function K(n,e){if(void 0===n)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const t=[];for(let e=0;e<n.count;e++){const r=n.getX(e),o=n.getY(e),a=n.getZ(e);t.push(`(${r.toPrecision(V)}, ${o.toPrecision(V)}, ${a.toPrecision(V)})`)}return t.join(", ")}function Q(n,t){const r="            ",o=[],a=[];function i(e,r,o){const a=e.id+(o?"_"+o.getHexString():""),i=1023===e.format;return t[a]=e,`\n        def Shader "Transform2d_${r}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${n.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${en(e.repeat)}\n            float2 inputs:translation = ${en(e.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${e.id}_${r}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${a}.${i?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${n.id}/Transform2d_${r}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${n.transparent||n.alphaTest>0?"float outputs:a":""}\n        }`}return n.side===e.DoubleSide&&console.warn("v3d.USDZExporter: USDZ does not support double sided materials",n),null!==n.map?(o.push(`${r}color3f inputs:diffuseColor.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:rgb>`),n.transparent?o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:a>`):n.alphaTest>0&&(o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:a>`),o.push(`${r}float inputs:opacityThreshold = ${n.alphaTest}`)),a.push(i(n.map,"diffuse",n.color))):o.push(`${r}color3f inputs:diffuseColor = ${nn(n.color)}`),null!==n.emissiveMap?(o.push(`${r}color3f inputs:emissiveColor.connect = </Materials/Material_${n.id}/Texture_${n.emissiveMap.id}_emissive.outputs:rgb>`),a.push(i(n.emissiveMap,"emissive"))):n.emissive.getHex()>0&&o.push(`${r}color3f inputs:emissiveColor = ${nn(n.emissive)}`),null!==n.normalMap&&(o.push(`${r}normal3f inputs:normal.connect = </Materials/Material_${n.id}/Texture_${n.normalMap.id}_normal.outputs:rgb>`),a.push(i(n.normalMap,"normal"))),null!==n.aoMap&&(o.push(`${r}float inputs:occlusion.connect = </Materials/Material_${n.id}/Texture_${n.aoMap.id}_occlusion.outputs:r>`),a.push(i(n.aoMap,"occlusion"))),null!==n.roughnessMap&&1===n.roughness?(o.push(`${r}float inputs:roughness.connect = </Materials/Material_${n.id}/Texture_${n.roughnessMap.id}_roughness.outputs:g>`),a.push(i(n.roughnessMap,"roughness"))):o.push(`${r}float inputs:roughness = ${n.roughness}`),null!==n.metalnessMap&&1===n.metalness?(o.push(`${r}float inputs:metallic.connect = </Materials/Material_${n.id}/Texture_${n.metalnessMap.id}_metallic.outputs:b>`),a.push(i(n.metalnessMap,"metallic"))):o.push(`${r}float inputs:metallic = ${n.metalness}`),null!==n.alphaMap?(o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.alphaMap.id}_opacity.outputs:r>`),o.push(`${r}float inputs:opacityThreshold = 0.0001`),a.push(i(n.alphaMap,"opacity"))):o.push(`${r}float inputs:opacity = ${n.opacity}`),n.isMeshPhysicalMaterial&&(o.push(`${r}float inputs:clearcoat = ${n.clearcoat}`),o.push(`${r}float inputs:clearcoatRoughness = ${n.clearcoatRoughness}`),o.push(`${r}float inputs:ior = ${n.ior}`)),`\n    def Material "Material_${n.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${n.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${n.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${a.join("\n")}\n\n    }\n`}function nn(n){return`(${n.r}, ${n.g}, ${n.b})`}function en(n){return`(${n.x}, ${n.y})`}n.USDZExporter=class{async parse(n,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}}},e);const t={},r="model.usda";t[r]=null;let o=Y();o+=function(n){return`def Xform "Root"\n{\n    def Scope "Scenes" (\n        kind = "sceneLibrary"\n    )\n    {\n        def Xform "Scene" (\n            customData = {\n                bool preliminary_collidesWithEnvironment = 0\n                string sceneName = "Scene"\n            }\n            sceneName = "Scene"\n        )\n        {\n        token preliminary:anchoring:type = "${n.ar.anchoring.type}"\n        token preliminary:planeAnchoring:alignment = "${n.ar.planeAnchoring.alignment}"\n\n`}(e);const a={},i={};n.traverseVisible((n=>{if(n.isMesh){const e=n.geometry,r=n.material;if(r.isMeshStandardMaterial){const i="geometries/Geometry_"+e.id+".usd";if(!(i in t)){const n=function(n){const e=function(n){const e="Geometry",t=n.attributes,r=t.position.count;return`\n    def Mesh "${e}"\n    {\n        int[] faceVertexCounts = [${function(n){const e=null!==n.index?n.index.count:n.attributes.position.count;return Array(e/3).fill(3).join(", ")}(n)}]\n        int[] faceVertexIndices = [${function(n){const e=n.index,t=[];if(null!==e)for(let n=0;n<e.count;n++)t.push(e.getX(n));else{const e=n.attributes.position.count;for(let n=0;n<e;n++)t.push(n)}return t.join(", ")}(n)}]\n        normal3f[] normals = [${K(t.normal,r)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${K(t.position,r)}]\n        float2[] primvars:st = [${function(n,e){if(void 0===n)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const t=[];for(let e=0;e<n.count;e++){const r=n.getX(e),o=n.getY(e);t.push(`(${r.toPrecision(V)}, ${1-o.toPrecision(V)})`)}return t.join(", ")}(t.uv,r)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(n);return`\ndef "Geometry"\n{\n  ${e}\n}\n`}(e);t[i]=function(n){let e=Y();return e+=n,X(e)}(n)}r.uuid in a||(a[r.uuid]=r),o+=function(n,e,t){const r="Object_"+n.id,o=q(n.matrixWorld);n.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",n);return`def Xform "${r}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${o}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${t.id}>\n}\n\n`}(n,e,r)}else console.warn("v3d.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",n)}else n.isCamera&&(o+=function(n){const e=n.name?n.name:"Camera_"+n.id,t=q(n.matrixWorld);n.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",n);return n.isOrthographicCamera?`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${t}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${n.near.toPrecision(V)}, ${n.far.toPrecision(V)})\n            float horizontalAperture = ${(10*(Math.abs(n.left)+Math.abs(n.right))).toPrecision(V)}\n            float verticalAperture = ${(10*(Math.abs(n.top)+Math.abs(n.bottom))).toPrecision(V)}\n            token projection = "orthographic"\n        }\n\n    `:`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${t}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${n.near.toPrecision(V)}, ${n.far.toPrecision(V)})\n            float focalLength = ${n.getFocalLength().toPrecision(V)}\n            float focusDistance = ${n.focus.toPrecision(V)}\n            float horizontalAperture = ${n.getFilmWidth().toPrecision(V)}\n            token projection = "perspective"\n            float verticalAperture = ${n.getFilmHeight().toPrecision(V)}\n        }\n\n    `}(n))})),o+="\n        }\n    }\n}\n\n",o+=function(n,e){const t=[];for(const r in n){const o=n[r];t.push(Q(o,e))}return`def "Materials"\n{\n${t.join("")}\n}\n\n`}(a,i),t[r]=X(o),o=null;for(const n in i){const e=i[n],r=n.split("_")[1],o=1023===e.format,a=G(e.image,r),s=await new Promise((n=>a.toBlob(n,o?"image/png":"image/jpeg",1)));t[`textures/Texture_${n}.${o?"png":"jpg"}`]=new Uint8Array(await s.arrayBuffer())}let s=0;for(const n in t){const e=t[n];s+=34+n.length;const r=63&s;if(4!==r){const o=new Uint8Array(64-r);t[n]=[e,{extra:{12345:o}}]}s=e.length}return F(t,{level:0})}}}(v3d,v3d);

// exportToUSDZ puzzle
function exportToUSDZ(objSelector) {

    if (objSelector === '' || objSelector === PzLib.LIST_NONE) {

        var obj = appInstance.scene;

    } else {

        var obj = PzLib.getObjectByName(objSelector);
    }

    if (!obj)
        return;

    // COMPAT: iOS < 14
    if (Blob.prototype.arrayBuffer == undefined)
        Blob.prototype.arrayBuffer = function() {
            return new Response(this).arrayBuffer()
        }

    var usdzExporter = new v3d.USDZExporter();

    return new Promise(function(resolve, reject) {

        usdzExporter.parse(obj).then(function(value) {

            var dataUrl = URL.createObjectURL(new Blob([value], { type: 'application/octet-stream' }));
            resolve(dataUrl);

        }, function(reason) {

            console.error('exportToUSDZ: export failed: ' + reason);
            reject(reason);

        });

    });

}

// getHTMLElemAttribute puzzle
function getHTMLElemAttribute(attr, id, isParent) {
    var elem = PzLib.getElement(id, isParent);
    return elem ? elem[attr]: '';
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


if (featureAvailable('RETINA')) {
  setScreenScale(window.devicePixelRatio);
}
if (featureAvailable('RETINA')) {
  setScreenScale(1.5);
}

changeVis(['Floor_marble', 'Plinthe_black', 'Sphere_black'], false);

eventHTMLElem('click', 'blue_color', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_blue_mick');
});
eventHTMLElem('click', 'red_color', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_red');
});

eventHTMLElem('click', 'radio_socle_oui', true, function(event) {
  if (isObjectVisible('kong_62cm')) {
    changeVis('Pedestal_100', true);
    changeVis('Pedestal_29', false);
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    zoomCamera('kong_62cm', 1, function() {});
  } else {
    changeVis('Pedestal_29', true);
    changeVis('Pedestal_100', false);
    setObjTransform('kong_150cm', false, 'position', ['', '', 0.306], false);
    zoomCamera('kong_150cm', 1, function() {});
  }
});

eventHTMLElem('pointerup', 'oui_ar', true, function(event) {
  const elem = document.createElement('a'); elem.innerHTML = '<img>';
  if (elem && !actionDisabled) {
    actionDisabled=!0;function b(c,d){const e=a();return b=function(f,g){f=f-0x0;let h=e[f];return h;},b(c,d);}const n=b,exportedObject=app.scene.getObjectByName('Empty');if(!exportedObject)return;app[n(0x0)][n(0x1)](),app[n(0x2)]=![];const options='allowsContentScaling=0';elem[n(0x3)]='ar',elem[n(0x4)]=n(0x5),document[n(0x6)](n(0x7))[n(0x8)][n(0x9)]=n(0xa);const geometrySaved={},objects=new v3d[(n(0xb))]();function a(){const r=['clock','stop','enableRender','rel','download','ar.usdz','getElementById','v3d-container','style','filter','blur(3px)','Group','name','usdzObjects','length','count','getX','getY','getZ','setXYZ','traverseVisible','isMesh','morphTargetInfluences','geometry','clone','applyMatrix4','matrix','morphAttributes','Mesh','material','attributes','normal','position','add','scene','then','remove','objCache','start','href','click','revokeObjectURL','removeAttribute','none'];a=function(){return r;};return a();}objects[n(0xc)]=n(0xd);function am(c,d,e){const o=b;for(let f=0x0;f<d[o(0xe)];f++){if(e[f]==0x0)continue;for(let g=0x0;g<c[o(0xf)];g++){const h=c[o(0x10)](g)+d[f][o(0x10)](g)*e[f],k=c[o(0x11)](g)+d[f][o(0x11)](g)*e[f],l=c[o(0x12)](g)+d[f][o(0x12)](g)*e[f];c[o(0x13)](g,h,k,l);}}}exportedObject[n(0x14)](function(c){const p=b;if(c[p(0x15)]){if(c[p(0x16)]){let d=0x0;for(let m=0x0;m<c[p(0x16)][p(0xe)];m++)d+=c[p(0x16)][m];if(!d)return;const e=c[p(0x17)][p(0x18)]();e[p(0x19)](c[p(0x1a)]),e[p(0x1b)]={};const f=new v3d[(p(0x1c))](e,c[p(0x1d)]),g=f[p(0x17)][p(0x1e)][p(0x1f)],h=f[p(0x17)][p(0x1e)][p(0x20)],j=c[p(0x17)][p(0x1b)][p(0x1f)],k=c[p(0x17)][p(0x1b)][p(0x20)],l=c[p(0x16)];am(g,j,l),am(h,k,l),objects[p(0x21)](f);}else objects[p(0x21)](c[p(0x18)]());}}),app[n(0x22)][n(0x21)](objects),exportToUSDZ(objects[n(0xc)])[n(0x23)](function(c){const q=b;app[q(0x22)][q(0x24)](objects);for(const d in _pGlob[q(0x25)])delete _pGlob[q(0x25)][d];onceReadyDo(),app[q(0x0)][q(0x26)](),app[q(0x2)]=!![];if(options[q(0xe)])c=c+'#'+options;elem[q(0x27)]=c,elem[q(0x28)](),URL[q(0x29)](elem[q(0x27)]),elem[q(0x2a)](q(0x27)),document[q(0x6)](q(0x7))[q(0x8)][q(0x9)]=q(0x2b),actionDisabled=!1,elem.remove()});
  }
  function onceReadyDo(){}
});

changeVis(['Pedestal_29', 'Pedestal_100', 'kong_150cm'], false);

assignMat(['kong_62cm', 'kong_150cm'], 'metal_red');

eventHTMLElem('click', '25cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [0.403, 0.403, 0.403], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '30cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [0.483, 0.483, 0.483], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '37cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [0.595, 0.595, 0.595], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '52cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [0.839, 0.839, 0.839], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '62cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [1, 1, 1], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '80cm', true, function(event) {
  setObjTransform('kong_62cm', false, 'scale', [1.291, 1.291, 1.291], false);
  changeVis('kong_150cm', false);
  changeVis('kong_62cm', true);
  zoomCamera('kong_62cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_62cm', false, 'position', ['', '', 1.01], false);
    changeVis('Pedestal_29', false);
    changeVis('Pedestal_100', true);
  }
});
eventHTMLElem('click', '110cm', true, function(event) {
  setObjTransform('kong_150cm', false, 'scale', [0.732, 0.732, 0.732], false);
  changeVis('kong_62cm', false);
  changeVis('kong_150cm', true);
  zoomCamera('kong_150cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_150cm', false, 'position', ['', '', 0.306], false);
    changeVis('Pedestal_100', false);
    changeVis('Pedestal_29', true);
  }
});
eventHTMLElem('click', '150cm', true, function(event) {
  setObjTransform('kong_150cm', false, 'scale', [1, 1, 1], false);
  changeVis('kong_62cm', false);
  changeVis('kong_150cm', true);
  zoomCamera('kong_150cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_150cm', false, 'position', ['', '', 0.306], false);
    changeVis('Pedestal_100', false);
    changeVis('Pedestal_29', true);
  }
});
eventHTMLElem('click', '180cm', true, function(event) {
  setObjTransform('kong_150cm', false, 'scale', [1.199, 1.199, 1.199], false);
  changeVis('kong_62cm', false);
  changeVis('kong_150cm', true);
  zoomCamera('kong_150cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_150cm', false, 'position', ['', '', 0.306], false);
    changeVis('Pedestal_100', false);
    changeVis('Pedestal_29', true);
  }
});
eventHTMLElem('click', '230cm', true, function(event) {
  setObjTransform('kong_150cm', false, 'scale', [1.533, 1.533, 1.533], false);
  changeVis('kong_62cm', false);
  changeVis('kong_150cm', true);
  zoomCamera('kong_150cm', 0.5, function() {});
  if (getHTMLElemAttribute('checked', 'radio_socle_oui', true)) {
    setObjTransform('kong_150cm', false, 'position', ['', '', 0.306], false);
    changeVis('Pedestal_100', false);
    changeVis('Pedestal_29', true);
  }
});

eventHTMLElem('click', 'classic_red', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_red');
});
eventHTMLElem('click', 'classic_black', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_black');
});
eventHTMLElem('click', 'classic_white', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_white');
});
eventHTMLElem('click', 'classic_twitterblue', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_blue');
});
eventHTMLElem('click', 'classic_yellow', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_yellow');
});

eventHTMLElem('click', 'craquele_red', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_red');
});
eventHTMLElem('click', 'craquele_pink', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_pink');
});
eventHTMLElem('click', 'craquele_turquoise', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_turquoise');
});
eventHTMLElem('click', 'craquele_blue', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_blue');
});
eventHTMLElem('click', 'craquele_orange', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_orange');
});
eventHTMLElem('click', 'craquele_gold', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_gold');
});
eventHTMLElem('click', 'craquele_silver', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'craquele_silver');
});

eventHTMLElem('click', 'background_marble', true, function(event) {
  changeVis(['Floor_wood', 'Plinthe_wood', 'Sphere_blanc'], false);
  changeVis(['Floor_marble', 'Plinthe_black', 'Sphere_black'], true);
});

eventHTMLElem('click', 'radio_socle_non', true, function(event) {
  setObjTransform(['kong_62cm', 'kong_150cm'], false, 'position', ['', '', 0], false);
  changeVis('Pedestal_29', false);
  changeVis('Pedestal_100', false);
  if (isObjectVisible('kong_62cm')) {
    zoomCamera('kong_62cm', 1, function() {});
  } else {
    zoomCamera('kong_150cm', 1, function() {});
  }
});

eventHTMLElem('click', 'background_wood', true, function(event) {
  changeVis(['Floor_marble', 'Plinthe_black', 'Sphere_black'], false);
  changeVis(['Floor_wood', 'Plinthe_wood', 'Sphere_blanc'], true);
});

eventHTMLElem('click', 'clear_red', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'clear_red');
});
eventHTMLElem('click', 'clear_orange', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'clear_orange');
});
eventHTMLElem('click', 'clear_pink', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'clear_pink');
});
eventHTMLElem('click', 'clear_blue', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'clear_blue');
});
eventHTMLElem('click', 'clear_roche', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'clear_roche');
});
eventHTMLElem('click', 'classic_yellow', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'classic_yellow');
});

eventHTMLElem('click', 'metal_red', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_red');
});
eventHTMLElem('click', 'metal_mick', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_blue_mick');
});
eventHTMLElem('click', 'metal_galactik', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_blue_galactik');
});
eventHTMLElem('click', 'metal_mauritius', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_blue_mauritius');
});
eventHTMLElem('click', 'metal_fushia', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_fushia');
});
eventHTMLElem('click', 'metal_yellow', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_yellow');
});

eventHTMLElem('click', 'mat_red', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'mat_red');
});
eventHTMLElem('click', 'mat_mauritius', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'metal_blue_mauritius');
});
eventHTMLElem('click', 'mat_grey', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'mat_grey');
});
eventHTMLElem('click', 'mat_black', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'mat_black');
});

eventHTMLElem('click', 'af_greencandy', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'autref_green');
});
eventHTMLElem('click', 'af_dbb', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'autref_dbb');
});

eventHTMLElem('click', 'logo_tag', true, function(event) {
  assignMat(['kong_62cm', 'kong_150cm'], 'autreref_tag180');
});

eventHTMLElem('click', 'camera_tag', true, function(event) {
  if (kong_tag_30cm_cegid00000 == true) {
    setHTMLElemStyle('display', 'block', 'photo_kong_tag_30cm_cegid00000', true);
  }
  kong_tag_30cm_cegid00000 = false;
});

eventHTMLElem('click', 'camera_tag', true, function(event) {
  if (kong_tag_62cm_cegid11111 == true) {
    setHTMLElemStyle('display', 'block', 'photo_kong_tag_62cm_cegid11111', true);
  }
  kong_tag_62cm_cegid11111 = false;
});

eventHTMLElem('click', 'camera_tag', true, function(event) {
  if (kong_tag_180cm_cegid22222 == true) {
    setHTMLElemStyle('display', 'block', 'photo_kong_tag_62cm_cegid11111', true);
  }
  kong_tag_180cm_cegid22222 = false;
});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
