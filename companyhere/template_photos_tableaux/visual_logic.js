/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.6.0
 * Thu, 16 May 2024 08:42:52 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    /**
     * Get an HTML element by the given id.
     * @param {(string|Array<string>)} id An HTML element id or an array in the
     * format ["CONTAINER"] (app's container HTML element), or in the format
     * ["WINDOW"] (page's window object), or in the format ["DOCUMENT"] (page's
     * document object), or in the format ["BODY"] (document's body element) or in
     * the format ["QUERYSELECTOR"] (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for the element.
     * @returns {?(HTMLElement|Window|Document)} An HTML element, window,
     * document depending on the given "id" parameter or "null" if nothing was
     * found.
     */
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
    
    /**
     * Get an array of HTML elements or a single HTML element by the given ids/id.
     * @param {Array<string>} ids An array of HTML element ids or an array with its
     * first element being "CONTAINER" (app's container HTML element),
     * "WINDOW" (page's window object), "DOCUMENT" (page's document object),
     * "BODY" (document's body element) or "QUERYSELECTOR" (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for elements.
     * @returns {?(Array<?HTMLElement>|HTMLElement|Window|Document)} An array of
     * HTML elements or a single HTML element, window, document depending on the
     * given "ids" parameter or "null" if nothing was found.
     */
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    /**
     * Check if the given object is "worth processing", i.e. not irrelevant nor
     * purely utilitarian. This function is useful for listing all relevant objects
     * from a scene (see "objectList" and "groupList" puzzles) and for filtering out
     * irrelevant ones when traversing a scene.
     * @param {v3d.Object3D} obj Object to check.
     * @returns {boolean} Check result.
     */
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
    
    /**
     * Get object by its name from the scene.
     * @param {string} objName Object name.
     * @returns {?v3d.Object3D} Object or null if not found.
     */
    function getObjectByName(objName) {
        let objFound = null;
    
        const runTime = _pGlob !== undefined;
        if (runTime && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (runTime) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    /**
     * Get the names of all objects belonging to the given group.
     * @param {string} groupName Group name.
     * @returns {Array<string>} Array of names of all objects belonging to the given
     * group.
     */
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    /**
     * Get the names of all objects on the scene.
     * @returns {Array<string>} Array of names of all scene objects.
     */
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    /**
     * Accumulate object names from the given "currObjNames" parameter.
     * This is just a helper function which is supposed to be called from
     * "retrieveObjectNames".
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @param {Array<string>} namesAccum Array accumulating object names.
     */
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    /**
     * Retreive object names from the given "objNames" parameter which potentially
     * represents an object, or an array of objects, or a group or all objects at
     * once. Empty string names ('') are always filtered out.
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @returns {Array<string>} Array of retrieved object names.
     */
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    /**
     * Get the coordinate system of the current scene.
     * @returns {string} Scene's coordinate system.
     */
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
    
    /**
     * Check whether 2 event listeners are the same or not.
     * NOTE: "capture" is the only option that affects the fact if the listeners are
     * the same or not.
     * @see https://dom.spec.whatwg.org/#ref-for-dom-eventtarget-addeventlistener%E2%91%A2
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal
     * @param {EventTarget} target0 Event target the first event listener is
     * registered on.
     * @param {string} type0 Event type of the first even listener.
     * @param {?Function} listener0 Listener object (null, function or an object
     * with a handleEvent() method) of the first event listener.
     * @param {(Object|boolean)} optionsOrUseCapture0 Event listener options (or the
     * useCapture flag) of the first event listener.
     * @param {EventTarget} target1 Event target the second listener is registered
     * on.
     * @param {string} type1 Event type of the second even listener.
     * @param {?Function} listener1 Listener object (null, function or an object
     * with a handleEvent() method) of the second event listener.
     * @param {(Object|boolean)} optionsOrUseCapture1 Event listener options (or the
     * useCapture flag) of the second event listener.
     * @returns {boolean} Check result.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
    
    /**
     * Add the specified event listener to the specified event target. Also register
     * it in _pGlob.eventListeners for easier removal further. This function doesn't
     * add the exact same listener if it was already added.
     *
     * NOTE: automatic removal of an event listener via options.once and
     * options.signal is not reflected in _pGlob.eventListeners. In such cases
     * one must call unbindListener() manually to keep _pGlob.eventListeners
     * updated and to avoid potential issues with how the code checks if the given
     * listener already exists in _pGlob.eventListeners or not.
     *
     * @param {EventTarget} target Event target.
     * @param {string} type Event type.
     * @param {?Function} listener Listener object (null, function or an object
     * with a handleEvent() method).
     * @param {(Object|boolean)} optionsOrUseCapture Event listener options (or the
     * useCapture flag).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    /**
     * Get offset coordinates from the given mouse or touch browser event.
     * @param {(MouseEvent|TouchEvent)} event Mouse or touch event.
     * @param {number} touchId Identifier of a particular touch contact point.
     * Used only for touch events.
     * @param {v3d.Vector2} dest Destination vector.
     * @returns {v3d.Vector2} Destination vector filled with the event's offset
     * coordinates.
     */
    function getEventOffsetCoords(event, touchId, dest) {
        if (event instanceof MouseEvent) {
            dest.set(event.offsetX, event.offsetY);
        } else if (window.TouchEvent && event instanceof TouchEvent) {
            const rect = event.target.getBoundingClientRect();
            let touches = event.touches;
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                touches = event.changedTouches;
            }
    
            let touch = touches[0];
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === touchId) {
                    touch = touches[i];
                    break;
                }
            }
    
            dest.set(touch.clientX - rect.left, touch.clientY - rect.top);
        }
        return dest;
    }
    
    /**
     * Check whether the given touch contact point identifier corresponds to a
     * changed touch (from event.changedTouches) or not. For non-touch events simply
     * returns "true".
     * @param {(MouseEvent|TouchEvent)} event Touch or other event.
     * @param {number} touchId Identifier of a particular touch contact point.
     * Used only for touch events.
     * @returns {boolean} Check result.
     */
    function isChangedTouchOrNotTouchEventAtAll(event, touchId) {
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                let isChanged = false;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchId) {
                        isChanged = true;
                        break;
                    }
                }
                return isChanged;
            }
        }
    
        return true;
    }
    
    /**
     * Get the identifier of the first touch contact point for the given touch
     * event.
     * @param {TouchEvent} event Touch event.
     * @returns {number} Identifier of the first touch contact point or -1 if the
     * given event is not TouchEvent.
     */
    function getEventFirstTouchId(event) {
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                return event.changedTouches[0].identifier;
            } else {
                return event.touches[0].identifier;
            }
        }
        return -1;
    }
    
    /**
     * Get the name of the given object. This function also considers auto-generated
     * child meshes of multi-material objects.
     * @param {v3d.Object3D} obj The object.
     * @returns {string} The name of the object.
     */
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
    
    /**
     * Object for storing various event data required by the "whenDraggedOver"
     * puzzle block.
     * @typedef {Object} DragOverInfo
     * @property {string} draggedObjName Name of the currently dragged object.
     * @property {number} downX Mouse or touch event's offsetX coordinate of the
     * point where dragging started.
     * @property {number} downY Mouse or touch event's offsetY coordinate of the
     * point where dragging started.
     * @property {number} prevX Mouse or touch event's offsetX coordinate of the
     * previous point during dragging.
     * @property {number} prevY Mouse or touch event's offsetY coordinate of the
     * previous point during dragging.
     * @property {number} currX Mouse or touch event's offsetX coordinate of the
     * current point during dragging.
     * @property {number} currY Mouse or touch event's offsetY coordinate of the
     * current point during dragging.
     * @property {boolean} isDowned Flag telling if the mouse is already down or the
     * touch already started.
     * @property {boolean} isMoved Flag telling if the mouse or the touch point
     * moved during dragging.
     * @property {number} touchId Identifier of the touch contact point. Used only
     * for touch events.
     * @property {v3d.Vector3} downPointWorld 3D point (world space) on the
     * currently dragged object where dragging started.
     */
    
    /**
     * Create a DragOverInfo object.
     * @returns {DragOverInfo} Newly created DragOverInfo object.
     */
    function createDragOverInfo() {
        return {
            draggedObjName: '',
            downX: 0, downY: 0,
            prevX: 0, prevY: 0,
            currX: 0, currY: 0,
            isDowned: false,
            isMoved: false,
            touchId: -1,
            downPointWorld: new v3d.Vector3(),
        };
    }
    
    /**
     * A function to use as a callback for the initObjectPicking function. It's
     * supposed to handle the results of object picking.
     * @callback pickObjectCallback
     * @param {Array<Object>} intersects The array containing the results of object
     * picking in the form of intersection data from raycasting. Has the same format
     * as the result of the v3d.Raycaster's intersectObjects() method.
     * @param {(MouseEvent|TouchEvent)} event The event that was used for object
     * picking.
     */
    
    /**
     * Bind object picking functionality to the given mouse event, e.g. "mousemove",
     * "mousedown", "dblclick". An additional listener for a touch event
     * ("touchstart" or "touchend") is also registered.
     * @param {pickObjectCallback} callback A callback function receiving the
     * results of object picking.
     * @param {string} eventType The type of a MouseEvent, e.g. "mousemove",
     * "mousedown", "dblclick".
     * @param {boolean} [mouseDownUseTouchStart=false] Use the "touchstart" (if true)
     * or the "touchend" (if false) touch event for object picking for touch devices.
     * @param {Array<number>} [allowedMouseButtons=null] The array representing
     * mouse buttons allowed to trigger object picking. 0 - left mouse button,
     * 1 - middle mouse button, 2 - right mouse button. "null" (by default) means
     * that object picking will be triggered regardless of any mouse buttons pressed
     * (useful for events that don't require button pressing, e.g. "mousemove").
     * [0, 1, 2] means that a mouse event caused by pressing any of those buttons
     * will trigger object picking (useful for filtering out unwanted actions, e.g.
     * usually clicking with the middle/right mouse buttons).
     */
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    /**
     * Check if a particular object is among the given array of objects. This
     * function also considers auto-generated child meshes of multi-material
     * objects.
     * @param {string} objNameToCheck The name of the object to check if it's among
     * the given array of objects.
     * @param {Array} objNames Array of the object names to search in.
     * @returns {boolean} Check result.
     */
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    /**
     * Remove the specified event listener from the specified event target. Also
     * unregister it from _pGlob.eventListeners.
     * @param {EventTarget} target Event target.
     * @param {string} type Event type.
     * @param {?Function} listener Listener object (null, function or an object
     * with a handleEvent() method).
     * @param {(Object|boolean)} optionsOrUseCapture Event listener options (or the
     * useCapture flag).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     */
    function unbindListener(target, type, listener, optionsOrUseCapture) {
        const index = _pGlob.eventListeners.findIndex(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
        });
    
        if (index !== -1) {
            target.removeEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.splice(index, 1);
        }
    }
        
    /**
     * Transform the given coordinates from one space to another. Can be used with
     * both v3d.Vector3 or v3d.Euler.
     * @param {(v3d.Vector3|v3d.Euler)} coords Coordinates to transform.
     * @param {string} spaceFrom Space to transform from.
     * @param {string} spaceTo Space to transform into.
     * @param {boolean} [noSignChange=false] Don't change a component's sign in case
     * of the Z->(-Y), Y->(-Z) transformations. "true" is relevant for vectors
     * containing values that shouldn't change the sign (e.g. scale, dimension,
     * etc...).
     * @returns {(v3d.Vector3|v3d.Euler)} Transformed coordinates.
     */
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
    
    /**
     * Transform the given euler rotation from Verge3D's to Blender/Max's coordinate
     * system while also choosing the shortest rotation to resemble Blender's
     * behavior:
     * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Maxdefault
     * order) via reversion: XYZ -> ZYX.
     * 2) Swizzle ZYX->YZX.
     * 3) Choose the shortest rotation.
     *
     * @param {v3d.Euler} euler Euler rotation in Verge3D's coordinate system.
     * @param {v3d.Euler} dest Destination euler vector.
     * @returns {v3d.Euler} Destination vector filled with the transformed
     * coordinates.
     */
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    /**
     * Create a new RotationInterface object.
     * @class
     * @classdesc Class for facilitating rotations similar to how they work in
     * Blender/Max/Maya's UI. E.g. the axes for user rotations are similar to
     * Blender's "Gimbal" object gizmos for translation ("Move").
     */
    function RotationInterface() {
        /**
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
    
    /**
     * Traverse the given object and its descendants except the ones that represent
     * XR controllers, then execute the given callback for non-controller objects.
     * @param {Object3D} obj The object.
     * @param {Function} callback The function to be called for each non-controller
     * Object3D during the traverse and receives that object as a parameter. It's
     * similar to the callback parameter in Object3D's traverse() method.
     */
    function xrTraverseNonControllers(obj, callback) {
        if (obj.name.startsWith('XR_CONTROLLER_')) {
            return;
        }
    
        callback(obj);
    
        const children = obj.children;
        for (let i = 0, l = children.length; i < l; i++) {
            xrTraverseNonControllers(children[i], callback);
        }
    };
    
    /**
     * Get intersections between the given XR controller's target ray and objects in
     * the current scene (excluding XR controller objects).
     * @param {v3d.Group} controller A group representing an XR controller
     * (specifically the target ray space of the controller). Can be obtained by
     * calling WebXRManager's getController() method (WebXRManager can be accessed
     * through app's renderer.xr property).
     * @returns {Array<Object>} The array containing intersection data for the ray
     * casted from the XR controller. Has the same format as the result of the
     * v3d.Raycaster's intersectObjects() method.
     */
    function xrGetIntersections(controller) {
        controller.updateMatrixWorld(true);
    
        _pGlob.mat4Tmp.identity().extractRotation(controller.matrixWorld);
    
        const objList = [];
        xrTraverseNonControllers(appInstance.scene, obj => objList.push(obj));
    
        const raycaster = new v3d.Raycaster();
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(_pGlob.mat4Tmp);
    
        return raycaster.intersectObjects(objList, false);
    }
        
    /**
     * An event handler for the "select" XRInputSourceEvent. Binds object picking
     * functionality to the XR controller's primary action.
     * @param {Object} event An event dispatched to the XR controller object.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Inputs#primary_action|Primary action}
     */
    function xrOnSelect(event) {
        if (!_pGlob.objClickInfo) {
            return;
        }
    
        const controller = event.target;
        const intersections = xrGetIntersections(controller);
    
        if (intersections.length > 0) {
            const intersection = intersections[0];
            const obj = intersection.object;
    
            // save the object for the pickedObject block
            _pGlob.pickedObject = getObjectName(obj);
    
            _pGlob.objClickInfo.forEach(el => {
                const isPicked = obj && isObjectAmongObjects(getObjectName(obj),
                        retrieveObjectNames(el.objSelector));
                el.callbacks[isPicked ? 0 : 1]();
            });
        } else {
            // missed
            _pGlob.objClickInfo.forEach(el => el.callbacks[1]());
        }
    }
        
    /**
     * Default value used in certain list selector puzzles like "objectList",
     * "groupList", "animationList" and "materialList". Useful for checking for the
     * "nothing selected" case.
     * @constant
     * @type {string}
     * @default
     */
    const LIST_NONE = '<none>';

    return {
        getElements, getObjectByName, retrieveObjectNames, getSceneCoordSystem,
        bindListener, getEventOffsetCoords, isChangedTouchOrNotTouchEventAtAll, getEventFirstTouchId,
        getObjectName, createDragOverInfo, initObjectPicking, isObjectAmongObjects,
        unbindListener, transformCoordsSpace, transformEulerV3dToBlenderShortest, RotationInterface,
        xrOnSelect, LIST_NONE,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = false;


// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemAttribute('innerHTML', String(Math.round(_initGlob.percentage)) + '%', 'progress_bar', true);
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'page_chargement', true);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}



var mode, _cam_pos, prompt_clone;

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'CHROMEOS':
        return /(CrOS)/.test(userAgent);
    case 'LINUX':
        return /Linux/.test(platform);

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBAUDIO':
        return v3d.Detector.checkWebAudio();
    case 'WEBGL':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl')
        return !!gl;
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        var woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
        return !!woo_fun;
    case 'DO_NOT_TRACK':
        if (navigator.doNotTrack == '1' || window.doNotTrack == '1')
            return true;
        else
            return false;
    default:
        return false;
    }

}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

const intersectPlaneCSS = (() => {
    const coords = new v3d.Vector2();
    const rc = new v3d.Raycaster(); // always check visibility

    return (plane, cssX, cssY, dest) => {
        coords.x = (cssX / appInstance.getWidth()) * 2 - 1;
        coords.y = - (cssY / appInstance.getHeight()) * 2 + 1;
        rc.setFromCamera(coords, appInstance.getCamera(true));
        return rc.ray.intersectPlane(plane, dest);
    };
})();

// dragMoveAdv puzzle
const dragMoveAdv = (() => {
    _pGlob.dragMoveOrigins = _pGlob.dragMoveOrigins || {};

    // Blender/Max right-handed -> Verge3D right-handed
    const Z_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Z,
        Z: _pGlob.AXIS_Y,
    });

    // Blender/Max right-handed -> Verge3D right-handed with a camera parent
    const Z_UP_RIGHT_CAM_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    // Maya right-handed -> Verge3D right-handed
    const Y_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    const draggedObjPosWorld = new v3d.Vector3();
    const dragAxisWorld = new v3d.Vector3(); // only for the X, Y and Z modes
    const dragPlaneNorWorld = new v3d.Vector3();
    const dragPlane = new v3d.Plane();
    const intersectPoint0 = new v3d.Vector3();
    const intersectPoint1 = new v3d.Vector3();
    const dragDelta = new v3d.Vector3();
    const parentMatWorldInv = new v3d.Matrix3();

    return (objSelector, mode, spaceType, blockId, parentDragOverBlockId) => {
        const camera = appInstance.getCamera();
        if (!camera) return;

        if (!_pGlob.objDragOverInfoByBlock) return;

        const objNames = PzLib.retrieveObjectNames(objSelector);

        const info = _pGlob.objDragOverInfoByBlock[parentDragOverBlockId];
        if (!info) return;

        const draggedObj = PzLib.getObjectByName(info.draggedObjName);
        if (!draggedObj) return;

        if (!(blockId in _pGlob.dragMoveOrigins)) {
            _pGlob.dragMoveOrigins[blockId] = [];
        }
        const posOrigins = _pGlob.dragMoveOrigins[blockId];
        const lenDiff = objNames.length - posOrigins.length;
        for (let i = 0; i < lenDiff; i++) {
            posOrigins.push(new v3d.Vector3());
        }

        for (let i = 0; i < objNames.length; i++) {
            const obj = PzLib.getObjectByName(objNames[i]);
            if (!obj) continue;

            const posOrigin = posOrigins[i];
            if (!info.isMoved) {
                // the object position before the first move is used as an initial value
                posOrigin.copy(obj.position);
            }

            const isZupRight = PzLib.getSceneCoordSystem() === 'Z_UP_RIGHT';
            const needParentCamCoords = obj.parent && obj.parent.isCamera
                    && spaceType === 'PARENT';
            const coords = isZupRight
                    ? (needParentCamCoords ? Z_UP_RIGHT_CAM_COORDS : Z_UP_RIGHT_COORDS)
                    : Y_UP_RIGHT_COORDS;

            const isMode1d = mode === 'X' || mode === 'Y' || mode === 'Z';
            const isMode2d = mode === 'XY' || mode === 'XZ' || mode === 'YZ';
            const isMode3d = mode === 'XYZ';

            // determining the normal for the drag plane to raycast against
            if (isMode1d) {

                dragAxisWorld.copy(coords[mode]);

                if (spaceType === 'LOCAL') {
                    dragAxisWorld.transformDirection(obj.matrixWorld);
                } else if (spaceType === 'PARENT') {
                    dragAxisWorld.transformDirection(obj.parent.matrixWorld);
                } else {
                    // considered to be in the world space, no need for transforming
                }

                camera.getWorldDirection(dragPlaneNorWorld);
                dragPlaneNorWorld.cross(dragAxisWorld).cross(dragAxisWorld);

            } else if (isMode2d) {

                const modeNormal = mode === 'XY' ? 'Z' : (mode === 'XZ' ? 'Y' : 'X');
                dragPlaneNorWorld.copy(coords[modeNormal]);

                if (spaceType === 'LOCAL') {
                    dragPlaneNorWorld.transformDirection(obj.matrixWorld);
                } else if (spaceType === 'PARENT') {
                    dragPlaneNorWorld.transformDirection(obj.parent.matrixWorld);
                } else {
                    // considered to be in the world space, no need for transforming
                }

            } else {

                camera.getWorldDirection(dragPlaneNorWorld);

            }

            draggedObj.getWorldPosition(draggedObjPosWorld);
            dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNorWorld, draggedObjPosWorld);

            const res0 = intersectPlaneCSS(dragPlane, info.downX, info.downY,
                    intersectPoint0);
            const res1 = intersectPlaneCSS(dragPlane, info.currX, info.currY,
                    intersectPoint1);

            if (res0 !== null && res1 !== null) {
                dragDelta.subVectors(intersectPoint1, intersectPoint0);
                if (isMode1d) {
                    dragDelta.projectOnVector(dragAxisWorld);
                }

                parentMatWorldInv.setFromMatrix4(obj.parent.matrixWorld).invert();
                dragDelta.applyMatrix3(parentMatWorldInv);
                obj.position.addVectors(posOrigin, dragDelta);
            }

            obj.updateMatrixWorld(true);
        }
    };
})();

// whenDraggedOver puzzle
_pGlob.objDragOverInfoGlobal = [];
_pGlob.objDragOverInfoByBlock = {}

PzLib.initObjectPicking(function(intersects, downEvent) {

    _pGlob.objDragOverInfoGlobal.forEach(function(el) {

        if (downEvent instanceof MouseEvent)
            if (el.mouseButtons.indexOf(downEvent.button) == -1)
                return;

        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, [el.objName])) {
                el.callback({
                    downEvent: downEvent,
                    draggedObjName: objName,
                    downPointWorld: intersects[i].point,
                });
            }

        }

    });

}, 'mousedown', true);

// whenDraggedOver puzzle
function registerOnDrag(objSelector, xRay, mouseButtons, cbStart, cbMove, cbDrop, blockId) {

    var cb = function(cbParam) {

        if (appInstance.controls) {
            appInstance.controls.enabled = false;
        }

        if (!(blockId in _pGlob.objDragOverInfoByBlock)) {
            _pGlob.objDragOverInfoByBlock[blockId] = PzLib.createDragOverInfo();
        }
        var info = _pGlob.objDragOverInfoByBlock[blockId];

        // NOTE: don't use more than one pointing event, e.g. don't process
        // some events related to multitouch actions
        if (info.isDowned) {
            return;
        }

        var touchId = PzLib.getEventFirstTouchId(cbParam.downEvent);
        var coords = PzLib.getEventOffsetCoords(cbParam.downEvent, touchId,
                _pGlob.vec2Tmp);

        info.downX = info.prevX = info.currX = coords.x;
        info.downY = info.prevY = info.currY = coords.y;
        info.touchId = touchId;
        info.isDowned = true;
        info.isMoved = false;
        info.draggedObjName = cbParam.draggedObjName;
        info.downPointWorld.copy(cbParam.downPointWorld);

        cbStart(cbParam.downEvent);

        var elem = appInstance.container;

        var moveCb = function(e) {
            if (!PzLib.isChangedTouchOrNotTouchEventAtAll(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = PzLib.getEventOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.prevX = info.currX;
            info.prevY = info.currY;
            info.currX = coords.x;
            info.currY = coords.y;
            cbMove(e);
            info.isMoved = true;
        }
        var upCb = function(e) {
            if (!PzLib.isChangedTouchOrNotTouchEventAtAll(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = PzLib.getEventOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.currX = coords.x;
            info.currY = coords.y;
            info.prevX = info.currX;
            info.prevY = info.currY;
            cbDrop(e);
            info.isDowned = false;

            PzLib.unbindListener(elem, 'mousemove', moveCb);
            PzLib.unbindListener(elem, 'touchmove', moveCb);
            PzLib.unbindListener(elem, 'mouseup', upCb);
            PzLib.unbindListener(elem, 'touchend', upCb);
            if (appInstance.controls) {
                appInstance.controls.enabled = true;
            }
        }

        PzLib.bindListener(elem, 'mousemove', moveCb);
        PzLib.bindListener(elem, 'touchmove', moveCb);
        PzLib.bindListener(elem, 'mouseup', upCb);
        PzLib.bindListener(elem, 'touchend', upCb);
    }

    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        _pGlob.objDragOverInfoGlobal.push({
            objName: objName,
            callback: cb,
            xRay: xRay,
            mouseButtons: mouseButtons
        });
    }
}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// getObjTransform puzzle
function getObjTransform(objName, isWorldSpace, mode, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = PzLib.getSceneCoordSystem();

    var transformVal;

    if (isWorldSpace && obj.parent) {
        if (mode === 'position') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldPosition(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'rotation') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldEuler(_pGlob.eulerTmp, 'XYZ'), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'scale') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldScale(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        }

    } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);

    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = PzLib.RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);

    } else {
        transformVal = PzLib.transformCoordsSpace(obj[mode].clone(),
                'Y_UP_RIGHT', coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}

// arHitPoint puzzle
function arHitPoint(coord) {

    if (!_pGlob.arHitPoint) {
        if (coord == 'xyz')
            return [0, 0, 0];
        else
            return 0;
    }

    var hitPoint = PzLib.transformCoordsSpace(_pGlob.vec3Tmp.copy(_pGlob.arHitPoint),
            'Y_UP_RIGHT', PzLib.getSceneCoordSystem());

    if (coord == 'xyz')
        return hitPoint.toArray();
    else
        return hitPoint[coord];
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = PzLib.RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}

// arHitTest puzzle
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.arHitNormal = new v3d.Vector3(0, 0, 0);

function arHitTest(cbHit, cbMiss, smooth) {
    appInstance.renderer.xr.arHitTest(0, 0, function(point, normal) {

        smooth = v3d.MathUtils.clamp(smooth, 0, 1);

        var x = point.x;
        var y = point.y;
        var z = point.z;

        _pGlob.arHitPoint.x = _pGlob.arHitPoint.x * smooth + (1 - smooth) * x;
        _pGlob.arHitPoint.y = _pGlob.arHitPoint.y * smooth + (1 - smooth) * y;
        _pGlob.arHitPoint.z = _pGlob.arHitPoint.z * smooth + (1 - smooth) * z;

        _pGlob.arHitNormal.lerpVectors(normal, _pGlob.arHitNormal, smooth);

        cbHit();
    }, cbMiss);
}

// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};

// setObjDirection puzzle
function setObjDirection(objSelector, vector, isPoint, lockUp) {
    var objNames = PzLib.retrieveObjectNames(objSelector);
    var x = vector[0] || 0;
      var y = vector[1] || 0;
      var z = vector[2] || 0;

    var coords = PzLib.transformCoordsSpace(_pGlob.vec3Tmp.set(x, y, z),
            PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (!isPoint) {
            coords.normalize().add(obj.position);
        }

        if (lockUp) {
            // NOTE: partially copy-pasted from LockedTrackConstraint

            var targetWorldPos = new v3d.Vector3(coords.x, coords.y, coords.z);

            var lockDir = new v3d.Vector3(0, 1, 0);

            if (obj.isCamera || obj.isLight)
                var trackDir = new v3d.Vector3(0, 0, -1);
            else
                var trackDir = new v3d.Vector3(0, 0, 1);

            var projDir = new v3d.Vector3();
            var plane = _pGlob.planeTmp;

            var objWorldPos = new v3d.Vector3();
            objWorldPos.setFromMatrixPosition(obj.matrixWorld);

            plane.setFromNormalAndCoplanarPoint(lockDir, objWorldPos);
            plane.projectPoint(targetWorldPos, projDir).sub(objWorldPos);

            var sign = _pGlob.vec3Tmp2.crossVectors(trackDir, projDir).dot(lockDir) > 0 ? 1 : -1;

            obj.setRotationFromAxisAngle(plane.normal, sign * trackDir.angleTo(projDir));

            if (obj.parent) {
                obj.parent.matrixWorld.decompose(_pGlob.vec3Tmp2, _pGlob.quatTmp, _pGlob.vec3Tmp2);
                obj.quaternion.premultiply(_pGlob.quatTmp.invert());
            }

        } else {

            obj.lookAt(coords.x, coords.y, coords.z);

        }

        obj.updateMatrixWorld(true);
    }
}

// enterARMode puzzle
function enterARMode(refSpace, allowHTML, enterCb, exitCb, unAvailableCb) {

    switch (refSpace) {
        case 'SITTING':
            var referenceSpace = 'local-floor';
            break;
        case 'WALKING':
            var referenceSpace = 'unbounded';
            break;
        case 'ORIGIN':
            var referenceSpace = 'local';
            break;
        case 'ROOM':
            var referenceSpace = 'bounded-floor';
            break;
        case 'VIEWER':
            var referenceSpace = 'viewer';
            break;
        default:
            console.error('puzzles: Wrong VR reference space');
            return;
    }


    appInstance.initWebXR('immersive-ar', referenceSpace, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            PzLib.bindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.bindListener(controller, pair[0], pair[1]);
            });
        }

        _pGlob.xrSessionAcquired = true;

        enterCb();

    }, unAvailableCb, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            PzLib.unbindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.unbindListener(controller, pair[0], pair[1]);
            });
        }

        _pGlob.xrSessionAcquired = false;

        // to cleanup supplementary XR_CAMERA_CONTROL_OBJECT
        _pGlob.objCache = {};

        exitCb();

    }, { domOverlay: allowHTML });
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

var actionDisabled = false;

!function(n,e){"use strict";
/*!
   fflate - fast JavaScript compression/decompression
   <https://101arrowz.github.io/fflate>
   Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
   version 0.6.9
   */var t=function(n){return URL.createObjectURL(new Blob([n],{type:"text/javascript"}))};try{URL.revokeObjectURL(t(""))}catch(n){t=function(n){return"data:application/javascript;charset=UTF-8,"+encodeURI(n)}}var r=Uint8Array,o=Uint16Array,a=Uint32Array,i=new r([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),s=new r([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),u=new r([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(n,e){for(var t=new o(31),r=0;r<31;++r)t[r]=e+=1<<n[r-1];var i=new a(t[30]);for(r=1;r<30;++r)for(var s=t[r];s<t[r+1];++s)i[s]=s-t[r]<<5|r;return[t,i]},l=f(i,2),c=l[0],p=l[1];c[28]=258,p[258]=28;for(var h=f(s,0)[1],m=new o(32768),d=0;d<32768;++d){var g=(43690&d)>>>1|(21845&d)<<1;g=(61680&(g=(52428&g)>>>2|(13107&g)<<2))>>>4|(3855&g)<<4,m[d]=((65280&g)>>>8|(255&g)<<8)>>>1}var v=function(n,e,t){for(var r=n.length,a=0,i=new o(e);a<r;++a)++i[n[a]-1];var s,u=new o(e);for(a=0;a<e;++a)u[a]=u[a-1]+i[a-1]<<1;if(t){s=new o(1<<e);var f=15-e;for(a=0;a<r;++a)if(n[a])for(var l=a<<4|n[a],c=e-n[a],p=u[n[a]-1]++<<c,h=p|(1<<c)-1;p<=h;++p)s[m[p]>>>f]=l}else for(s=new o(r),a=0;a<r;++a)n[a]&&(s[a]=m[u[n[a]-1]++]>>>15-n[a]);return s},$=new r(288);for(d=0;d<144;++d)$[d]=8;for(d=144;d<256;++d)$[d]=9;for(d=256;d<280;++d)$[d]=7;for(d=280;d<288;++d)$[d]=8;var M=new r(32);for(d=0;d<32;++d)M[d]=5;var x=v($,9,0),w=v(M,5,0),y=function(n){return(n/8|0)+(7&n&&1)},_=function(n,e,t){(null==e||e<0)&&(e=0),(null==t||t>n.length)&&(t=n.length);var i=new(n instanceof o?o:n instanceof a?a:r)(t-e);return i.set(n.subarray(e,t)),i},b=function(n,e,t){t<<=7&e;var r=e/8|0;n[r]|=t,n[r+1]|=t>>>8},S=function(n,e,t){t<<=7&e;var r=e/8|0;n[r]|=t,n[r+1]|=t>>>8,n[r+2]|=t>>>16},U=function(n,e){for(var t=[],a=0;a<n.length;++a)n[a]&&t.push({s:a,f:n[a]});var i=t.length,s=t.slice();if(!i)return[E,0];if(1==i){var u=new r(t[0].s+1);return u[t[0].s]=1,[u,1]}t.sort((function(n,e){return n.f-e.f})),t.push({s:-1,f:25001});var f=t[0],l=t[1],c=0,p=1,h=2;for(t[0]={s:-1,f:f.f+l.f,l:f,r:l};p!=i-1;)f=t[t[c].f<t[h].f?c++:h++],l=t[c!=p&&t[c].f<t[h].f?c++:h++],t[p++]={s:-1,f:f.f+l.f,l:f,r:l};var m=s[0].s;for(a=1;a<i;++a)s[a].s>m&&(m=s[a].s);var d=new o(m+1),g=T(t[p-1],d,0);if(g>e){a=0;var v=0,$=g-e,M=1<<$;for(s.sort((function(n,e){return d[e.s]-d[n.s]||n.f-e.f}));a<i;++a){var x=s[a].s;if(!(d[x]>e))break;v+=M-(1<<g-d[x]),d[x]=e}for(v>>>=$;v>0;){var w=s[a].s;d[w]<e?v-=1<<e-d[w]++-1:++a}for(;a>=0&&v;--a){var y=s[a].s;d[y]==e&&(--d[y],++v)}g=e}return[new r(d),g]},T=function(n,e,t){return-1==n.s?Math.max(T(n.l,e,t+1),T(n.r,e,t+1)):e[n.s]=t},D=function(n){for(var e=n.length;e&&!n[--e];);for(var t=new o(++e),r=0,a=n[0],i=1,s=function(n){t[r++]=n},u=1;u<=e;++u)if(n[u]==a&&u!=e)++i;else{if(!a&&i>2){for(;i>138;i-=138)s(32754);i>2&&(s(i>10?i-11<<5|28690:i-3<<5|12305),i=0)}else if(i>3){for(s(a),--i;i>6;i-=6)s(8304);i>2&&(s(i-3<<5|8208),i=0)}for(;i--;)s(a);i=1,a=n[u]}return[t.subarray(0,r),e]},k=function(n,e){for(var t=0,r=0;r<e.length;++r)t+=n[r]*e[r];return t},P=function(n,e,t){var r=t.length,o=y(e+2);n[o]=255&r,n[o+1]=r>>>8,n[o+2]=255^n[o],n[o+3]=255^n[o+1];for(var a=0;a<r;++a)n[o+a+4]=t[a];return 8*(o+4+r)},j=function(n,e,t,r,a,f,l,c,p,h,m){b(e,m++,t),++a[256];for(var d=U(a,15),g=d[0],y=d[1],_=U(f,15),T=_[0],j=_[1],A=D(g),E=A[0],O=A[1],C=D(T),Z=C[0],R=C[1],L=new o(19),I=0;I<E.length;++I)L[31&E[I]]++;for(I=0;I<Z.length;++I)L[31&Z[I]]++;for(var H=U(L,7),W=H[0],N=H[1],X=19;X>4&&!W[u[X-1]];--X);var z,B,F,G,V=h+5<<3,Y=k(a,$)+k(f,M)+l,q=k(a,g)+k(f,T)+l+14+3*X+k(L,W)+(2*L[16]+3*L[17]+7*L[18]);if(V<=Y&&V<=q)return P(e,m,n.subarray(p,p+h));if(b(e,m,1+(q<Y)),m+=2,q<Y){z=v(g,y,0),B=g,F=v(T,j,0),G=T;var J=v(W,N,0);b(e,m,O-257),b(e,m+5,R-1),b(e,m+10,X-4),m+=14;for(I=0;I<X;++I)b(e,m+3*I,W[u[I]]);m+=3*X;for(var K=[E,Z],Q=0;Q<2;++Q){var nn=K[Q];for(I=0;I<nn.length;++I){var en=31&nn[I];b(e,m,J[en]),m+=W[en],en>15&&(b(e,m,nn[I]>>>5&127),m+=nn[I]>>>12)}}}else z=x,B=$,F=w,G=M;for(I=0;I<c;++I)if(r[I]>255){en=r[I]>>>18&31;S(e,m,z[en+257]),m+=B[en+257],en>7&&(b(e,m,r[I]>>>23&31),m+=i[en]);var tn=31&r[I];S(e,m,F[tn]),m+=G[tn],tn>3&&(S(e,m,r[I]>>>5&8191),m+=s[tn])}else S(e,m,z[r[I]]),m+=B[r[I]];return S(e,m,z[256]),m+B[256]},A=new a([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),E=new r(0),O=function(){for(var n=new a(256),e=0;e<256;++e){for(var t=e,r=9;--r;)t=(1&t&&3988292384)^t>>>1;n[e]=t}return n}(),C=function(){var n=-1;return{p:function(e){for(var t=n,r=0;r<e.length;++r)t=O[255&t^e[r]]^t>>>8;n=t},d:function(){return~n}}},Z=function(n,e,t,u,f){return function(n,e,t,u,f,l){var c=n.length,m=new r(u+c+5*(1+Math.ceil(c/7e3))+f),d=m.subarray(u,m.length-f),g=0;if(!e||c<8)for(var v=0;v<=c;v+=65535){var $=v+65535;$<c?g=P(d,g,n.subarray(v,$)):(d[v]=l,g=P(d,g,n.subarray(v,c)))}else{for(var M=A[e-1],x=M>>>13,w=8191&M,b=(1<<t)-1,S=new o(32768),U=new o(b+1),T=Math.ceil(t/3),D=2*T,k=function(e){return(n[e]^n[e+1]<<T^n[e+2]<<D)&b},O=new a(25e3),C=new o(288),Z=new o(32),R=0,L=0,I=(v=0,0),H=0,W=0;v<c;++v){var N=k(v),X=32767&v,z=U[N];if(S[X]=z,U[N]=X,H<=v){var B=c-v;if((R>7e3||I>24576)&&B>423){g=j(n,d,0,O,C,Z,L,I,W,v-W,g),I=R=L=0,W=v;for(var F=0;F<286;++F)C[F]=0;for(F=0;F<30;++F)Z[F]=0}var G=2,V=0,Y=w,q=X-z&32767;if(B>2&&N==k(v-q))for(var J=Math.min(x,B)-1,K=Math.min(32767,v),Q=Math.min(258,B);q<=K&&--Y&&X!=z;){if(n[v+G]==n[v+G-q]){for(var nn=0;nn<Q&&n[v+nn]==n[v+nn-q];++nn);if(nn>G){if(G=nn,V=q,nn>J)break;var en=Math.min(q,nn-2),tn=0;for(F=0;F<en;++F){var rn=v-q+F+32768&32767,on=rn-S[rn]+32768&32767;on>tn&&(tn=on,z=rn)}}}q+=(X=z)-(z=S[X])+32768&32767}if(V){O[I++]=268435456|p[G]<<18|h[V];var an=31&p[G],sn=31&h[V];L+=i[an]+s[sn],++C[257+an],++Z[sn],H=v+G,++R}else O[I++]=n[v],++C[n[v]]}}g=j(n,d,l,O,C,Z,L,I,W,v-W,g),!l&&7&g&&(g=P(d,g+1,E))}return _(m,0,u+y(g)+f)}(n,null==e.level?6:e.level,null==e.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(n.length)))):12+e.mem,t,u,!f)},R=function(n,e){var t={};for(var r in n)t[r]=n[r];for(var r in e)t[r]=e[r];return t},L=function(n,e,t){for(;t;++e)n[e]=t,t>>>=8};function I(n,e){return Z(n,e||{},0,0)}var H=function(n,e,t,o){for(var a in n){var i=n[a],s=e+a;i instanceof r?t[s]=[i,o]:Array.isArray(i)?t[s]=[i[0],R(o,i[1])]:H(i,s+"/",t,o)}},W="undefined"!=typeof TextEncoder&&new TextEncoder,N="undefined"!=typeof TextDecoder&&new TextDecoder;try{N.decode(E,{stream:!0}),1}catch(n){}function X(n,e){if(e){for(var t=new r(n.length),o=0;o<n.length;++o)t[o]=n.charCodeAt(o);return t}if(W)return W.encode(n);var a=n.length,i=new r(n.length+(n.length>>1)),s=0,u=function(n){i[s++]=n};for(o=0;o<a;++o){if(s+5>i.length){var f=new r(s+8+(a-o<<1));f.set(i),i=f}var l=n.charCodeAt(o);l<128||e?u(l):l<2048?(u(192|l>>6),u(128|63&l)):l>55295&&l<57344?(u(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++o))>>18),u(128|l>>12&63),u(128|l>>6&63),u(128|63&l)):(u(224|l>>12),u(128|l>>6&63),u(128|63&l))}return _(i,0,s)}var z=function(n){var e=0;if(n)for(var t in n){var r=n[t].length;if(r>65535)throw"extra field too long";e+=r+4}return e},B=function(n,e,t,r,o,a,i,s){var u=r.length,f=t.extra,l=s&&s.length,c=z(f);L(n,e,null!=i?33639248:67324752),e+=4,null!=i&&(n[e++]=20,n[e++]=t.os),n[e]=20,e+=2,n[e++]=t.flag<<1|(null==a&&8),n[e++]=o&&8,n[e++]=255&t.compression,n[e++]=t.compression>>8;var p=new Date(null==t.mtime?Date.now():t.mtime),h=p.getFullYear()-1980;if(h<0||h>119)throw"date not in range 1980-2099";if(L(n,e,h<<25|p.getMonth()+1<<21|p.getDate()<<16|p.getHours()<<11|p.getMinutes()<<5|p.getSeconds()>>>1),e+=4,null!=a&&(L(n,e,t.crc),L(n,e+4,a),L(n,e+8,t.size)),L(n,e+12,u),L(n,e+14,c),e+=16,null!=i&&(L(n,e,l),L(n,e+6,t.attrs),L(n,e+10,i),e+=14),n.set(r,e),e+=u,c)for(var m in f){var d=f[m],g=d.length;L(n,e,+m),L(n,e+2,g),n.set(d,e+4),e+=4+g}return l&&(n.set(s,e),e+=l),e};function F(n,e){e||(e={});var t={},o=[];H(n,"",t,e);var a=0,i=0;for(var s in t){var u=t[s],f=u[0],l=u[1],c=0==l.level?0:8,p=(b=X(s)).length,h=l.comment,m=h&&X(h),d=m&&m.length,g=z(l.extra);if(p>65535)throw"filename too long";var v=c?I(f,l):f,$=v.length,M=C();M.p(f),o.push(R(l,{size:f.length,crc:M.d(),c:v,f:b,m:m,u:p!=s.length||m&&h.length!=d,o:a,compression:c})),a+=30+p+g+$,i+=76+2*(p+g)+(d||0)+$}for(var x=new r(i+22),w=a,y=i-a,_=0;_<o.length;++_){var b=o[_];B(x,b.o,b,b.f,b.u,b.c.length);var S=30+b.f.length+z(b.extra);x.set(b.c,b.o+S),B(x,a,b,b.f,b.u,b.c.length,b.o,b.m),a+=16+S+(b.m?b.m.length:0)}return function(n,e,t,r,o){L(n,e,101010256),L(n,e+8,t),L(n,e+10,t),L(n,e+12,r),L(n,e+16,o)}(x,a,o.length,y,w),x}function G(n,e){if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&n instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap){const t=1024/Math.max(n.width,n.height),r=document.createElement("canvas");r.width=n.width*Math.min(1,t),r.height=n.height*Math.min(1,t);const o=r.getContext("2d");if(o.drawImage(n,0,0,r.width,r.height),void 0!==e){const n=parseInt(e,16),t=(n>>16&255)/255,a=(n>>8&255)/255,i=(255&n)/255,s=o.getImageData(0,0,r.width,r.height),u=s.data;for(let n=0;n<u.length;n+=4)u[n+0]=u[n+0]*t,u[n+1]=u[n+1]*a,u[n+2]=u[n+2]*i;o.putImageData(s,0,0)}return r}throw new Error("v3d.USDZExporter: No valid image data found. Unable to process texture.")}const V=7;function Y(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function q(n){const e=n.elements;return`(${J(e,0)}, ${J(e,4)}, ${J(e,8)}, ${J(e,12)})`}function J(n,e){return`(${n[e+0]}, ${n[e+1]}, ${n[e+2]}, ${n[e+3]})`}function K(n,e){if(void 0===n)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const t=[];for(let e=0;e<n.count;e++){const r=n.getX(e),o=n.getY(e),a=n.getZ(e);t.push(`(${r.toPrecision(V)}, ${o.toPrecision(V)}, ${a.toPrecision(V)})`)}return t.join(", ")}function Q(n,t){const r="            ",o=[],a=[];function i(e,r,o){const a=e.id+(o?"_"+o.getHexString():""),i=1023===e.format;return t[a]=e,`\n        def Shader "Transform2d_${r}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${n.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${en(e.repeat)}\n            float2 inputs:translation = ${en(e.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${e.id}_${r}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${a}.${i?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${n.id}/Transform2d_${r}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${n.transparent||n.alphaTest>0?"float outputs:a":""}\n        }`}return n.side===e.DoubleSide&&console.warn("v3d.USDZExporter: USDZ does not support double sided materials",n),null!==n.map?(o.push(`${r}color3f inputs:diffuseColor.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:rgb>`),n.transparent?o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:a>`):n.alphaTest>0&&(o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.map.id}_diffuse.outputs:a>`),o.push(`${r}float inputs:opacityThreshold = ${n.alphaTest}`)),a.push(i(n.map,"diffuse",n.color))):o.push(`${r}color3f inputs:diffuseColor = ${nn(n.color)}`),null!==n.emissiveMap?(o.push(`${r}color3f inputs:emissiveColor.connect = </Materials/Material_${n.id}/Texture_${n.emissiveMap.id}_emissive.outputs:rgb>`),a.push(i(n.emissiveMap,"emissive"))):n.emissive.getHex()>0&&o.push(`${r}color3f inputs:emissiveColor = ${nn(n.emissive)}`),null!==n.normalMap&&(o.push(`${r}normal3f inputs:normal.connect = </Materials/Material_${n.id}/Texture_${n.normalMap.id}_normal.outputs:rgb>`),a.push(i(n.normalMap,"normal"))),null!==n.aoMap&&(o.push(`${r}float inputs:occlusion.connect = </Materials/Material_${n.id}/Texture_${n.aoMap.id}_occlusion.outputs:r>`),a.push(i(n.aoMap,"occlusion"))),null!==n.roughnessMap&&1===n.roughness?(o.push(`${r}float inputs:roughness.connect = </Materials/Material_${n.id}/Texture_${n.roughnessMap.id}_roughness.outputs:g>`),a.push(i(n.roughnessMap,"roughness"))):o.push(`${r}float inputs:roughness = ${n.roughness}`),null!==n.metalnessMap&&1===n.metalness?(o.push(`${r}float inputs:metallic.connect = </Materials/Material_${n.id}/Texture_${n.metalnessMap.id}_metallic.outputs:b>`),a.push(i(n.metalnessMap,"metallic"))):o.push(`${r}float inputs:metallic = ${n.metalness}`),null!==n.alphaMap?(o.push(`${r}float inputs:opacity.connect = </Materials/Material_${n.id}/Texture_${n.alphaMap.id}_opacity.outputs:r>`),o.push(`${r}float inputs:opacityThreshold = 0.0001`),a.push(i(n.alphaMap,"opacity"))):o.push(`${r}float inputs:opacity = ${n.opacity}`),n.isMeshPhysicalMaterial&&(o.push(`${r}float inputs:clearcoat = ${n.clearcoat}`),o.push(`${r}float inputs:clearcoatRoughness = ${n.clearcoatRoughness}`),o.push(`${r}float inputs:ior = ${n.ior}`)),`\n    def Material "Material_${n.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${n.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${n.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${a.join("\n")}\n\n    }\n`}function nn(n){return`(${n.r}, ${n.g}, ${n.b})`}function en(n){return`(${n.x}, ${n.y})`}n.USDZExporter=class{async parse(n,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}}},e);const t={},r="model.usda";t[r]=null;let o=Y();o+=function(n){return`def Xform "Root"\n{\n    def Scope "Scenes" (\n        kind = "sceneLibrary"\n    )\n    {\n        def Xform "Scene" (\n            customData = {\n                bool preliminary_collidesWithEnvironment = 0\n                string sceneName = "Scene"\n            }\n            sceneName = "Scene"\n        )\n        {\n        token preliminary:anchoring:type = "${n.ar.anchoring.type}"\n        token preliminary:planeAnchoring:alignment = "${n.ar.planeAnchoring.alignment}"\n\n`}(e);const a={},i={};n.traverseVisible((n=>{if(n.isMesh){const e=n.geometry,r=n.material;if(r.isMeshStandardMaterial){const i="geometries/Geometry_"+e.id+".usd";if(!(i in t)){const n=function(n){const e=function(n){const e="Geometry",t=n.attributes,r=t.position.count;return`\n    def Mesh "${e}"\n    {\n        int[] faceVertexCounts = [${function(n){const e=null!==n.index?n.index.count:n.attributes.position.count;return Array(e/3).fill(3).join(", ")}(n)}]\n        int[] faceVertexIndices = [${function(n){const e=n.index,t=[];if(null!==e)for(let n=0;n<e.count;n++)t.push(e.getX(n));else{const e=n.attributes.position.count;for(let n=0;n<e;n++)t.push(n)}return t.join(", ")}(n)}]\n        normal3f[] normals = [${K(t.normal,r)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${K(t.position,r)}]\n        float2[] primvars:st = [${function(n,e){if(void 0===n)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const t=[];for(let e=0;e<n.count;e++){const r=n.getX(e),o=n.getY(e);t.push(`(${r.toPrecision(V)}, ${1-o.toPrecision(V)})`)}return t.join(", ")}(t.uv,r)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(n);return`\ndef "Geometry"\n{\n  ${e}\n}\n`}(e);t[i]=function(n){let e=Y();return e+=n,X(e)}(n)}r.uuid in a||(a[r.uuid]=r),o+=function(n,e,t){const r="Object_"+n.id,o=q(n.matrixWorld);n.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",n);return`def Xform "${r}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${o}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${t.id}>\n}\n\n`}(n,e,r)}else console.warn("v3d.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",n)}else n.isCamera&&(o+=function(n){const e=n.name?n.name:"Camera_"+n.id,t=q(n.matrixWorld);n.matrixWorld.determinant()<0&&console.warn("v3d.USDZExporter: USDZ does not support negative scales",n);return n.isOrthographicCamera?`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${t}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${n.near.toPrecision(V)}, ${n.far.toPrecision(V)})\n            float horizontalAperture = ${(10*(Math.abs(n.left)+Math.abs(n.right))).toPrecision(V)}\n            float verticalAperture = ${(10*(Math.abs(n.top)+Math.abs(n.bottom))).toPrecision(V)}\n            token projection = "orthographic"\n        }\n\n    `:`def Camera "${e}"\n        {\n            matrix4d xformOp:transform = ${t}\n            uniform token[] xformOpOrder = ["xformOp:transform"]\n\n            float2 clippingRange = (${n.near.toPrecision(V)}, ${n.far.toPrecision(V)})\n            float focalLength = ${n.getFocalLength().toPrecision(V)}\n            float focusDistance = ${n.focus.toPrecision(V)}\n            float horizontalAperture = ${n.getFilmWidth().toPrecision(V)}\n            token projection = "perspective"\n            float verticalAperture = ${n.getFilmHeight().toPrecision(V)}\n        }\n\n    `}(n))})),o+="\n        }\n    }\n}\n\n",o+=function(n,e){const t=[];for(const r in n){const o=n[r];t.push(Q(o,e))}return`def "Materials"\n{\n${t.join("")}\n}\n\n`}(a,i),t[r]=X(o),o=null;for(const n in i){const e=i[n],r=n.split("_")[1],o=1023===e.format,a=G(e.image,r),s=await new Promise((n=>a.toBlob(n,o?"image/png":"image/jpeg",1)));t[`textures/Texture_${n}.${o?"png":"jpg"}`]=new Uint8Array(await s.arrayBuffer())}let s=0;for(const n in t){const e=t[n];s+=34+n.length;const r=63&s;if(4!==r){const o=new Uint8Array(64-r);t[n]=[e,{extra:{12345:o}}]}s=e.length}return F(t,{level:0})}}}(v3d,v3d);

// exportToUSDZ puzzle
function exportToUSDZ(objSelector) {

    if (objSelector === '' || objSelector === PzLib.LIST_NONE) {

        var obj = appInstance.scene;

    } else {

        var obj = PzLib.getObjectByName(objSelector);
    }

    if (!obj)
        return;

    // COMPAT: iOS < 14
    if (Blob.prototype.arrayBuffer == undefined)
        Blob.prototype.arrayBuffer = function() {
            return new Response(this).arrayBuffer()
        }

    var usdzExporter = new v3d.USDZExporter();

    return new Promise(function(resolve, reject) {

        usdzExporter.parse(obj).then(function(value) {

            var dataUrl = URL.createObjectURL(new Blob([value], { type: 'application/octet-stream' }));
            resolve(dataUrl);

        }, function(reason) {

            console.error('exportToUSDZ: export failed: ' + reason);
            reject(reason);

        });

    });

}

// checkARMode puzzle
function checkARMode(availableCb, usdzCb, unAvailableCb) {
    v3d.Detector.checkWebXR('immersive-ar', availableCb, function() {
        const a = document.createElement("a");
        if (a.relList.supports("ar"))
            usdzCb();
        else
            unAvailableCb();
    });
}

// zoomCamera puzzle
function zoomCamera(objSelector, duration, doSlot) {

    duration = Math.max(0, duration);

    const objNames = PzLib.retrieveObjectNames(objSelector);

    const zoomObjects = [];
    objNames.forEach(function(name) {
        const obj = PzLib.getObjectByName(name);
        if (obj) {
            zoomObjects.push(obj);
        }
    });

    if (!zoomObjects.length) {
        return;
    }

    const camera = appInstance.getCamera();

    const zoom = [camera.zoom]; // for orthographic camera only

    const pos = _pGlob.vec3Tmp, target = _pGlob.vec3Tmp2;
    v3d.CameraUtils.calcCameraZoomToObjectsParams(camera, zoomObjects,
            pos, target, zoom);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            if (camera.isOrthographicCamera) {
                appInstance.controls.tweenZoomTo(target, zoom[0],
                        duration, doSlot);
            } else {
                appInstance.controls.tween(pos, target, duration, doSlot);
            }
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(pos);
        }
        camera.position.copy(pos);
        camera.lookAt(target);
        camera.zoom = zoom[0];
        camera.updateProjectionMatrix();
        doSlot();
    }
}

// dragRotateAdv puzzle
const dragRotateAdv = (() => {

    // Blender/Max right-handed -> Verge3D right-handed
    const Z_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Z,
        Z: _pGlob.AXIS_Y,
    });

    // Blender/Max right-handed -> Verge3D right-handed with a camera parent
    const Z_UP_RIGHT_CAM_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    // Maya right-handed -> Verge3D right-handed
    const Y_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    const axisVec = new v3d.Vector3();
    const axisVecLocal = new v3d.Vector3();

    const objQuatWorld = new v3d.Quaternion();
    const objQuatWorldConj = new v3d.Quaternion();
    const parentQuatWorld = new v3d.Quaternion();

    const objPosWorld = new v3d.Vector3();
    const axisLineEndPoint = new v3d.Vector3();
    const axisLine = new v3d.Line3();
    const downPointProjOnLine = new v3d.Vector3();

    const rotationPoint = new v3d.Vector3();
    const vecPointerFrom = new v3d.Vector2();
    const vecPointerTo = new v3d.Vector2();

    const viewVec = new v3d.Vector3();

    const rotationQuat = new v3d.Quaternion();

    return (objSelector, mode, spaceType, blockId, parentDragOverBlockId) => {

        const camera = appInstance.getCamera(true);
        if (!camera) return;

        if (!_pGlob.objDragOverInfoByBlock) return;
        const info = _pGlob.objDragOverInfoByBlock[parentDragOverBlockId];
        if (!info) return;

        const appWidth = appInstance.getWidth();
        const appHeight = appInstance.getHeight();

        const isZupRight = PzLib.getSceneCoordSystem() === 'Z_UP_RIGHT';

        const objNames = PzLib.retrieveObjectNames(objSelector);

        for (let i = 0; i < objNames.length; i++) {
            const obj = PzLib.getObjectByName(objNames[i]);
            if (!obj) continue;

            obj.getWorldQuaternion(objQuatWorld);

            const needParentCamCoords = obj.parent && obj.parent.isCamera
                    && spaceType === 'PARENT';
            const coords = isZupRight
                    ? (needParentCamCoords ? Z_UP_RIGHT_CAM_COORDS : Z_UP_RIGHT_COORDS)
                    : Y_UP_RIGHT_COORDS;
            axisVec.copy(coords[mode]);
            if (spaceType === 'LOCAL') {
                axisVec.applyQuaternion(objQuatWorld);
            } else if (spaceType === 'PARENT') {
                obj.parent.getWorldQuaternion(parentQuatWorld);
                axisVec.applyQuaternion(parentQuatWorld);
            } else {
                // considered to be in the world space, no need for transforming
            }

            obj.getWorldPosition(objPosWorld);

            axisLineEndPoint.addVectors(objPosWorld, axisVec);
            axisLine.set(objPosWorld, axisLineEndPoint);
            axisLine.closestPointToPoint(info.downPointWorld, false, downPointProjOnLine);

            rotationPoint.copy(downPointProjOnLine);
            rotationPoint.project(camera);

            const rotX = (rotationPoint.x + 1) / 2 * appWidth;
            const rotY = (-rotationPoint.y + 1) / 2 * appHeight;

            vecPointerFrom.set(info.prevX - rotX, info.prevY - rotY);
            vecPointerTo.set(info.currX - rotX, info.currY - rotY);

            objQuatWorldConj.copy(objQuatWorld).conjugate();
            axisVecLocal.copy(axisVec).applyQuaternion(objQuatWorldConj).normalize();

            /**
             * Negated in order to keep the rotation direction consistent with
             * mouse movement after transforming coordinates from the NDC space
             * to the canvas space.
             */
            let rotAngle = -(vecPointerTo.angle() - vecPointerFrom.angle());

            /**
             * Negated if the rotation axis points outwards the camera. Not
             * needed and can have issues for objects parented to camera.
             */
            if (!needParentCamCoords) {
                camera.getWorldDirection(viewVec);
                if (viewVec.dot(axisVec) > 0) {
                    rotAngle = -rotAngle;
                }
            }

            rotationQuat.setFromAxisAngle(axisVecLocal, rotAngle);

            obj.quaternion.multiply(rotationQuat);
            obj.updateMatrixWorld(true);
        }
    };
})();

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);
            var objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


changeVis(['indicator_invis_plane', 'prompt_move_around', 'drag_move', 'drag_rotate', 'ready_button'], false);

if (featureAvailable('MOBILE')) {
  setScreenScale(window.devicePixelRatio);
}
if (featureAvailable('MOBILE')) {
  setScreenScale(1.5);
}

mode = 'indicator';
_cam_pos = [];
prompt_clone = '';

registerOnDrag('drag_move', false, [0,1,2], function() {}, function() {
  dragMoveAdv('export_objet', 'XY', 'WORLD', '8o8nOyTtkWq?W_SQs-|_', 'G1ye9@dbVWAx+dC?wdwk');
}, function() {}, 'G1ye9@dbVWAx+dC?wdwk');

// Check AR capabilities
checkARMode(function() {
  // Enter AR!
  eventHTMLElem('pointerup', 'start_ar', true, function(event) {
    _cam_pos = getObjTransform(getActiveCamera(), false, 'position', 'x');
    setScreenScale(1);
    enterARMode('ORIGIN', true, function() {
      changeVis('export_objet', false);
      changeVis('prompt_move_around', true);
      arHitTest(function() {
        if (mode == 'indicator') {
          changeVis('indicator_invis_plane', true);
          setObjTransform('indicator_invis_plane', false, 'position', [arHitPoint('x'), arHitPoint('y'), arHitPoint('z')], false);
        }
        changeVis('prompt_move_around', false);
      }, function() {
        changeVis('indicator_invis_plane', false);
      }, 0.7);
      changeVis('edit_button', true);
      changeVis(['drag_move', 'drag_rotate', 'ready_button'], false);
    }, function() {
      setScreenScale(1.5);
      setObjTransform(getActiveCamera(), false, 'position', _cam_pos, false);
      changeVis('export_objet', true);
      changeVis('prompt_move_around', false);
      setObjTransform('export_objet', false, 'position', createVector(0, 0, 0), false);
      // Look at me!
      setObjDirection('export_objet', getObjTransform('Camera', false, 'position', 'xyz'), true, true);
      changeVis(['edit_button', 'ready_button', 'drag_move', 'drag_rotate'], false);
      setObjTransform('export_objet', false, 'scale', [1, 1, 1], false);
    }, function() {});
  });
}, function() {
  eventHTMLElem('pointerup', 'start_ar', true, function(event) {
    const elem = document.createElement('a'); elem.innerHTML = '<img>';
    if (elem && !actionDisabled) {
      actionDisabled=!0;function b(c,d){const e=a();return b=function(f,g){f=f-0x0;let h=e[f];return h;},b(c,d);}const n=b,exportedObject=app.scene.getObjectByName('export_objet');if(!exportedObject)return;app[n(0x0)][n(0x1)](),app[n(0x2)]=![];const options='allowsContentScaling=0';elem[n(0x3)]='ar',elem[n(0x4)]=n(0x5),document[n(0x6)](n(0x7))[n(0x8)][n(0x9)]=n(0xa);const geometrySaved={},objects=new v3d[(n(0xb))]();function a(){const r=['clock','stop','enableRender','rel','download','ar.usdz','getElementById','v3d-container','style','filter','blur(3px)','Group','name','usdzObjects','length','count','getX','getY','getZ','setXYZ','traverseVisible','isMesh','morphTargetInfluences','geometry','clone','applyMatrix4','matrix','morphAttributes','Mesh','material','attributes','normal','position','add','scene','then','remove','objCache','start','href','click','revokeObjectURL','removeAttribute','none'];a=function(){return r;};return a();}objects[n(0xc)]=n(0xd);function am(c,d,e){const o=b;for(let f=0x0;f<d[o(0xe)];f++){if(e[f]==0x0)continue;for(let g=0x0;g<c[o(0xf)];g++){const h=c[o(0x10)](g)+d[f][o(0x10)](g)*e[f],k=c[o(0x11)](g)+d[f][o(0x11)](g)*e[f],l=c[o(0x12)](g)+d[f][o(0x12)](g)*e[f];c[o(0x13)](g,h,k,l);}}}exportedObject[n(0x14)](function(c){const p=b;if(c[p(0x15)]){if(c[p(0x16)]){let d=0x0;for(let m=0x0;m<c[p(0x16)][p(0xe)];m++)d+=c[p(0x16)][m];if(!d)return;const e=c[p(0x17)][p(0x18)]();e[p(0x19)](c[p(0x1a)]),e[p(0x1b)]={};const f=new v3d[(p(0x1c))](e,c[p(0x1d)]),g=f[p(0x17)][p(0x1e)][p(0x1f)],h=f[p(0x17)][p(0x1e)][p(0x20)],j=c[p(0x17)][p(0x1b)][p(0x1f)],k=c[p(0x17)][p(0x1b)][p(0x20)],l=c[p(0x16)];am(g,j,l),am(h,k,l),objects[p(0x21)](f);}else objects[p(0x21)](c[p(0x18)]());}}),app[n(0x22)][n(0x21)](objects),exportToUSDZ(objects[n(0xc)])[n(0x23)](function(c){const q=b;app[q(0x22)][q(0x24)](objects);for(const d in _pGlob[q(0x25)])delete _pGlob[q(0x25)][d];onceReadyDo(),app[q(0x0)][q(0x26)](),app[q(0x2)]=!![];if(options[q(0xe)])c=c+'#'+options;elem[q(0x27)]=c,elem[q(0x28)](),URL[q(0x29)](elem[q(0x27)]),elem[q(0x2a)](q(0x27)),document[q(0x6)](q(0x7))[q(0x8)][q(0x9)]=q(0x2b),actionDisabled=!1,elem.remove()});
    }
    function onceReadyDo(){}
  });
}, function() {});

eventHTMLElem('click', 'tableau_avec_chevalet', true, function(event) {
  changeVis('socle', true);
  setObjTransform(['toile', 'cadre'], false, 'position', ['', '', 0.8], false);
  setObjTransform(['toile', 'cadre'], false, 'rotation', [-8.77, '', ''], false);
  zoomCamera('toile', 1, function() {});
});

registerOnDrag('drag_rotate', false, [0,1,2], function() {}, function() {
  dragRotateAdv('export_objet', 'Z', 'WORLD', ';V@_mj~C6#6st}%|L2fM', 'zs{d~:/oJ6OM9r)o6R,C');
}, function() {}, 'zs{d~:/oJ6OM9r)o6R,C');

registerOnClick('ready_button', false, false, [0,1,2], function() {
  registerSetTimeout(0.1, function() {
    changeVis(['drag_move', 'drag_rotate', 'ready_button'], false);
    changeVis('edit_button', true);
    changeVis('indicator_invis_plane', true);
    mode = 'indicator';
  });
}, function() {});
registerOnClick('edit_button', false, false, [0,1,2], function() {
  registerSetTimeout(0.1, function() {
    changeVis(['drag_move', 'drag_rotate', 'ready_button'], true);
    changeVis('edit_button', false);
    changeVis('indicator_invis_plane', false);
    mode = 'edit';
  });
}, function() {});

eventHTMLElem('click', 'tableau_sans_chevalet', true, function(event) {
  changeVis('socle', false);
  setObjTransform(['toile', 'cadre'], false, 'position', ['', '', 0], false);
  setObjTransform(['toile', 'cadre'], false, 'rotation', [0, '', ''], false);
  zoomCamera('toile', 1, function() {});
});

// Position the character
registerOnClick('indicator_invis_plane', false, false, [0,1,2], function() {
  changeVis('export_objet', true);
  changeVis(['drag_move', 'drag_rotate', 'ready_button'], false);
  setObjTransform('export_objet', false, 'position', [arHitPoint('x'), arHitPoint('y'), arHitPoint('z')], false);
  // Look at me!
  setObjDirection('export_objet', getObjTransform('Camera', false, 'position', 'xyz'), true, true);
}, function() {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
